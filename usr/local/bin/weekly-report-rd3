#!/bin/zsh
# shellcheck shell=bash disable=SC2004,SC2030,SC2031,SC2034,SC2046,SC2086,SC2116,SC2153,SC2154,SC2207,SC2248,SC2296,SC2312
# SC2004: ZSH does not spawn subshells like Bash does
# SC2030: ZSH does not spawn subshells like Bash does
# SC2034: parameters are used in a ZSH way
# SC2031: ZSH does not spawn subshells like Bash does
# SC2046: overly aggressive quoting recommendations
# SC2086: overly aggressive quoting recommendations
# SC2115: we need the echo in order to properly expand the parameter
# SC2153: COLUMN is assigned by ZSH
# SC2154: variables are assigned in a ZSH way
# SC2207: mapfile is a Bash thing
# SC2248: overly aggressive quoting recommendations
# SC2296: ZSH parameter expansion
# SC2312: silence command invocation recommendations

##########################################################################################
##########################################################################################
##
## weekly-report
##
## A BTD tool to report on weekly events, per Group and per Service.
##
##########################################################################################
##########################################################################################

setopt NO_CASE_MATCH
zmodload zsh/regex
autoload colors
colors

# This script complies with Semantic Versioning: http://semver.org/
# SC2016: $Hash is not a variable, it's a token that gets replaced by git(1)
typeset -ir v_major=0
typeset -ir v_minor=2
typeset -ir v_patch=9
# shellcheck disable=SC2016
typeset -r v_hash='$Hash$'

typeset -i VERBOSE=0
typeset -i SHOW_VERSION=0

# Prefer the instance in /usr/bin (that gets installed with the
# rdfetch package) over /usr/local/bin
if [[ -f /usr/bin/zsh-functions ]] ; then
    source /usr/bin/zsh-functions
elif [[ -f /usr/local/bin/zsh-functions ]] ; then
    source /usr/local/bin/zsh-functions
else
    print "Missing zsh-functions library. Cannot continue." >&2
    exit 1
fi

# Tell them how to use this command.
usage() {
  myName=${1}

  ${CAT} << EOF
SUMMARY

${myName:t}: Generate a report for a Rivendell Group and a Rivendell
Service for the week ending "yesterday" (or the specified date). This
version works only with Rivendell version 3.X.

SYNOPSIS

${myName:t} [ --start-date (-S) YYYY-MM-DD [HH:MM:SS] ]
              [ --end-date (-e) YYYY-MM-DD [HH:MM:SS] ]
              [ --group (-g) <Group Name> (or "list") ]
              [ --all ]
              [ --service (-s) Service-Name (or "list") ]
              [ --workstation (-w) Workstation-Name ]
              [ --schedcodes Code[,Code,...] (or "list") ]
              [ --csv (-c) ]
              [ --cuts (-C) ]
              [ --pro-data (-p) ]
              [ --verbose (-v) ]
	      [ --version (-V) ]

DESCRIPTION

The start date defaults to one week ago; the end date defaults to
yesterday if not specified.

${myName:t} prompts for a Group name if you do not provide one using the
--group (-g) parameter, or the --all option.

The --service (-s) parameter is required unless only one Service is
configured. In that case the sole Service is chosen for
you. ${myName:t} prompts for a Service if you do not specify it.

You may limit the search to a specific Rivendell workstation name with
the --workstation option. Use the word "all" to report playout history
for all workstations.

Using the --schedcodes option causes ${myName:t} to include Carts
that have any of the Scheduler Codes "Code,..." assigned (separate
multiple Codes with commas). You may use the word "list" to list and
choose from the available Scheduler Codes. This option also causes the
output to include all Rivendell Scheduler Codes for each Cart.

The --pro-data (-p) option tells ${myName:t} to include performance
rights organization (PRO) data (such as artist, album, and record
label) in the report output.

The "Len" field is reported using the form MM:SS when --csv is not
specified, and is represented as number of seconds (including the
fractional part) when --csv is specified.

Include Cut numbers in the output with the --cuts option.

${myName:t} generates Performance Totals (for each Cart) for the
period at the end of the report unless --csv is specified.

Increase the amount of output using the --verbose (-v) option.

Display the app version number and exit with the --version (-V)
option.

EOF
}

# Check to be sure it is a valid GROUP. Return true or false based on
# the regex match test
validGroup() {
  local knownGroups=${1} ; shift
  local requestedGroup=${1} ; shift

  [[ "${requestedGroup}" == '%' ]] || [[ "${knownGroups}" =~ .*${requestedGroup}.* ]]
}

# Check the (list of) Scheduler Code(s) agains the list of known
# Codes. Return true or false based on the regex match (return false
# on first failure).
validSchedCodes() {
  local knownSchedCodes=${1} ; shift
  local requestedSchedCodes=${1} ; shift
  local code
  local returnValue=0

  for code in $(echo ${requestedSchedCodes//,/ }) ; do
    [[ "${knownSchedCodes}" =~ .*${code}.* ]] || { returnValue=1 ; break ; }
  done

  return ${returnValue}
}

# Given a <Space>-separated list of Scheduler Codes, return a list
# separated by the desired delimiter
getSchedCodes() {
  local codes="${1}"
  local fieldSeparator=${2:-,}

  # SC2155: Don't care about the printf return code
  # shellcheck disable=SC2155
  local newCodes=$(printf "%s${fieldSeparator}" ${(z)codes})

  # To strip the trailing field separator.
  # SC2295: overly aggressive quoting recommendation
  # shellcheck disable=SC2295
  print ${newCodes%${fieldSeparator}}
}

# Find the longest title string in the selection for proper horizontal
# spacing in the text report.
maxLength() {
  local columnName=${1} ; shift

  local len
  local selectStatement="SELECT MAX(LENGTH(elr.${columnName})) FROM ELR_LINES AS elr
  				${schedCodesJoinClause}
				WHERE elr.cart_number IN
				(SELECT number FROM CART WHERE group_name ${whereClauseOp} '${group}'
				${schedCodesAndClause})
				AND
				elr.service_name = '${service}'
				AND
				elr.station_name LIKE '${stationName}'
				AND
				elr.event_datetime > '${reportStartDate}'
				AND
				elr.event_datetime <= '${reportEndDate}'
				ORDER BY elr.event_datetime"

  # This can return the word "NULL" so make sure it is reasonable.
  len=$(doSQL "${selectStatement}" | sed -e 's/NULL/0/')
  echo ${len}
}

quote() {
  local item="${1}"

  if ((CSV)) ; then
    print '\"'${item//\"/\"\"}'\"'
  else
    print ${item}
  fi
}

############# BEGIN external shell commands used in this script. #############
# This script uses these 5 external commands.
# Look for them in their upper case, parameter expanded form.
our_commands=( cat column getopt sort tr )
# Find the executables we need; this uses some basic shell and a ZSH trick:
# the (U) in the eval says to evaluate the parameter as all upper case
# letters. This snippet generates shell parameters representing the upper case
# equivalent of the command names and sets the parameter values to the full path
# of the commands.
# Refresh this segment in Emacs by marking the appropriate region (or the whole
# buffer with C-xH) and replacing it with C-uM-|mk-ourCommands --script (shell-command-on-region).
typeset C D
# SC2048: shellcheck overly aggressive quote recommendation.
# shellcheck disable=SC2048
for C in ${our_commands[*]} ; do
  # shellcheck disable=SC2154 # ZSH: ${path} is set by the shell.
  for D in ${path} ; do
    # shellcheck disable=SC2140,SC2086 # we need the quotes
    [[ -x "${D}/${C}" ]] && { eval "${(U)C//-/_}"="${D}/${C}" ; break ; }
  done
  [[ -x $(eval print \$"${(U)C//-/_}") ]] || { print "Cannot find ${C}! Done."; return 1 ; }
done
unset our_commands C D
############## END external shell commands used in this script. ##############

#CSV=0
typeset -i SCHEDCODES=0
# This will be set to 1 if requested on invocation.
typeset -i INCLUDE_CUTS=0
# This will be set to 4 (the number of PRO fields) if requested on
# invocation.
typeset -i PROdata=0

if ! TEMP=$(${GETOPT} -o acChg:s:S:e:pw:Vv --long all,csv,cuts,help,group:,schedcodes:,service:,start-date:,end-date:,pro-data,workstation:,version,verbose -n "${0:t}" -- "${@}") ; then
  print "getopt(1) Fatal Error (${?}). Terminating..." >&2
  return 1
fi
eval set -- "${TEMP}"
while : ; do
  case "${1}" in
    -a|--all) group=ALL_GROUPS ; shift ;;
    -c|--csv) CSV=1 ; shift ;;
    -C|--cut*) INCLUDE_CUTS=1 ; shift ;;
    -g|--grou*) group=${2} ; shift 2 ;;
    -s|--serv*) service=${2} ; shift 2 ;;
    --sched*) schedCodes=${2} ; shift 2 ;;
    -S|--star*) startDate=${2} ; shift 2 ;;
    -e|--end*) endDate=${2} ; shift 2 ;;
    -p|--pro*) PROdata=4 ; shift ;;
    -w|--work*) stationName="${2}" ; shift 2 ;;
    -h|--help) usage ${0} ; exit ;;
    -V|--vers*) SHOW_VERSION=1 ; shift ;;
    -v|--verb*) ((VERBOSE += 1)) ; shift ;;
    --) shift ; break ;;
    *) echo "Internal error, cannot continue!" >&2 ; exit 1 ;;
  esac
done
unset TEMP

if ((SHOW_VERSION)) ; then
  typeset commit_hash="${v_hash}"
  # SC2016: $Hash is not a variable.
  # shellcheck disable=SC2016
  [[ "${v_hash}" == '$Hash$' ]] && commit_hash="prerelase"
  # SC2299: ZSH parameters can nest
  # shellcheck disable=SC2299
  print "${0:t}: version ${v_major}.${v_minor}.${v_patch}-${${commit_hash#\$Hash: }%$}"
  exit 0
fi

# SC2154: these are set by ZSH for us.
# shellcheck disable=SC2154
typeset -r BOLD="${bold_color}"
# shellcheck disable=SC2154
typeset -r NORM="${reset_color}"

if ((CSV)) ; then
  typeset -r fs=,
else
  typeset -r fs='\t'
fi

# Snag the GROUP list for future use. This code works with GROUP names
# containing embedded <Space>s.
typeset -a rivendellGroupList
oIFS="${IFS}"
IFS=$'\t'
rivendellGroupList=( $(doSQL "SELECT name FROM GROUPS" | ${TR} '\012' '\t') )
IFS="${oIFS}"
unset oIFS

# Snag the SERVICES list for future use. SERVICES may not contain whitespace.
typeset -a rivendellServiceList
rivendellServiceList=( $(doSQL "SELECT name FROM SERVICES") )

# Snag the list of workstations from STATIONS.
typeset -a rivendellStations
rivendellStations=( $(doSQL "select NAME from STATIONS") )

# Snag the SCHED_CODES list for future use. Rivendell does not permit
# whitespace in CODE names.
if okDatabaseStructure SCHED_CODES:code ; then
  typeset -a rivendellSchedCodeList
  rivendellSchedCodeList=( $(doSQL "SELECT code from SCHED_CODES" | ${TR} '\012' '\t') )
else
  echo "${0:t}: Unknown database structure, table SCHED_CODES. Seek professional help." >&2
  exit 4
fi

typeset -A cartCount
whereClauseOp='='

if (( PROdata )) ; then
  typeset -a artist album label publisher
fi

# Default start date is midnight seven days ago.
if [[ -z "${startDate}" ]] ; then
  reportStartDate=$(strftime "%F 00:00:00" $(( EPOCHSECONDS - ( 60 * 60 * 24 * 7 ) )))
else
  # Be flexible in the start date they pass to us.
  if [[ "${startDate}" =~ ^[23][0-9]{3}-[01][0-9]-[0-3][0-9]$ ]] ; then
    reportStartDate="${startDate} 00:00:00"
  elif [[ "${startDate}" =~ ^[23][0-9]{3}-[01][0-9]-[0-3][0-9][[:space:]][012][0-9]:[0-9][0-9]$ ]] ; then
    reportStartDate="${startDate}:00"
  elif [[ "${startDate}" =~ ^[23][0-9]{3}-[01][0-9]-[0-3][0-9][[:space:]][012][0-9]:[0-9][0-9]:[0-9][0-9]$ ]] ; then
    reportStartDate="${startDate}"
  else
    echo "Start date '${startDate}' is invalid." >&2
    usage ${0:t}
    exit 2
  fi
fi

# Default end date is (almost) Midnight today (that is, report on
# everything through yesterday).
if [[ -z "${endDate}" ]] ; then
  reportEndDate=$(strftime "%F 23:59:59" $(( ${EPOCHSECONDS} - (60 * 60 * 24) )))
else
  if [[ "${endDate}" =~ ^[23][0-9]{3}-[01][0-9]-[0-3][0-9]$ ]] ; then
    reportEndDate="${endDate} 23:59:59"
  elif [[ "${endDate}" =~ [23][0-9]{3}-[01][0-9]-[0-3][0-9][[:space:]][012][0-9]:[0-9][0-9]$ ]] ; then
    reportEndDate="${endDate}:59"
  elif [[ "${endDate}" =~ [23][0-9]{3}-[01][0-9]-[0-3][0-9][[:space:]][012][0-9]:[0-9][0-9]:[0-9][0-9]$ ]] ; then
    reportEndDate="${endDate}"
  else
    echo "End date '${endDate}' is invalid." >&2
    usage ${0:t}
    exit 2
  fi
fi

((VERBOSE)) &&
  printf "%18s: Using Start Date: %s and End Date: %s\n" "${0:t}" "${startDate}" "${endDate}" >&2

# List the groups and prompt for a group to use in this report.
if [[ -n "${group}" ]] ; then
  if [[ "${group}" == 'ALL_GROUPS' ]] ; then
    group='%'
    whereClauseOp='LIKE'
  elif [[ "${group}" = 'list' ]] ; then
    echo "Current Groups:" >&2
    echo ${(F)rivendellGroupList} | ${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) >&2
    read -r group\?"Enter a Group to report: "
  fi
else
  echo "Current Groups:" >&2
  echo ${(F)rivendellGroupList} | ${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) >&2
  read -r group\?"Enter a Group to report: "
fi

validGroup "${rivendellGroupList[*]}" ${group} || {
  echo "${BOLD}${group} is not in the list. Please use a valid Group name.${NORM}" 1>&2
  exit 2
}

# List the SERVICES if there are more than one, otherwise use the lone SERVICE.
if [[ -z "${service}" ]] || [[ "${service}" = 'list' ]] ; then
  if (( ${#rivendellServiceList} > 1 )) ; then
    echo "Current Services:" >&2
    echo ${(F)rivendellServiceList} | ${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) >&2
    read -r service\?"Enter a Service on which to report: "
  else
    service=${rivendellServiceList[1]}
  fi
fi

# List the STATION names if they did not specify one, and if there is
# more than one, otherwise use the lone STATION_NAME.
if [[ -z "${stationName}" ]] || [[ "${stationName}" = 'list' ]] ; then
  if (( ${#rivendellStations} > 1 )) ; then
    echo "Workstations:" >&2
    echo ${(F)rivendellStations} | ${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) >&2
    read -r stationName\?"Enter a Station for which to report: "
  else
    stationName="${rivendellStations[1]}"
  fi
fi
if [[ "${stationName}" = 'all' ]] ; then
  stationName='%'
fi

# List the Scheduler Codes and prompt for one (or more) to use in this report.
if [[ "${schedCodes}" = 'list' ]] ; then
  echo "Current Scheduler Codes:" >&2
  echo ${(F)rivendellSchedCodeList} | ${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) >&2
  read -r schedCodes\?"Enter one or more Scheduler Code(s) to report (separate with ',' (comma): "
fi
if [[ -n "${schedCodes}" ]] ; then
  # Purge spaces just in case ...
  schedCodes=${schedCodes// /}

  validSchedCodes "${rivendellSchedCodeList[*]}" "${schedCodes}" || {
    echo "${BOLD}'${schedCodes//,/, }' is invalid. Please specify valid Scheduler Codes.${NORM}" >&2
    exit 3
  }
  typeset -a scA
  scA=( $(echo ${schedCodes//,/ }) )
  schedCodesJoinClause="LEFT JOIN CART_SCHED_CODES AS csch ON (elr.cart_number = csch.cart_number)"
  # SC2027: shellcheck does not quite understand quoting for ZSH.
  # shellcheck disable=SC2027
  schedCodesAndClause="AND csch.sched_code IN ($(echo "'"${(j:',':)scA}"'"))"
  SCHEDCODES=1

  typeset -a schedcodes
fi

# How many events will we report?
selectCountStatement="SELECT
  COUNT(*)
  FROM ELR_LINES AS elr
  LEFT JOIN CART AS c on (elr.cart_number = c.number)
  ${schedCodesJoinClause}
  WHERE elr.cart_number IN
  (SELECT number FROM CART WHERE group_name ${whereClauseOp} '${group}' ${schedCodesAndClause})
  AND elr.service_name = '${service}'
  AND
  elr.station_name LIKE '${stationName}'
  AND
  elr.event_datetime > '${reportStartDate}'
  AND
  elr.event_datetime <= '${reportEndDate}'
  ORDER BY elr.event_datetime"
((VERBOSE > 2)) &&
  print "${0:t}: eventCount SELECT: ${selectCountStatement}" >&2
eventCount=$(doSQL "${selectCountStatement}")

# The report title.
groupClause="$(if [[ ${group} =~ ^%$ ]] ; then print all Groups ; else print Group ${group} ; fi)"
reportTitleText="Service: ${service}: ${eventCount} Event$( ((eventCount > 1)) && echo s) in ${groupClause} between ${reportStartDate} and ${reportEndDate}"
((CSV)) || print "${reportTitleText}\n"

# Get the maximum length of each of these columns.
fwTitle=$(maxLength title)
fwArtist=$(maxLength artist)
fwAlbum=$(maxLength album)
fwLabel=$(maxLength label)
fwPub=$(maxLength publisher)

# The report header with optional column headings, based on invocation
# options.
if ((CSV)) ; then
  typeset header='"Air Date","Cart #"'
  ((INCLUDE_CUTS)) && header=${header}',"Cut #"'
  header=${header}',"Len","Title"'
  ((PROdata)) && header=${header}',"Artist","Album","Label","Publisher"'
  ((SCHEDCODES)) && header=${header}',"SchedCodes"'
  print "${header}"
else
  typeset headerFormat="%19s${fs}%6s"
  ((INCLUDE_CUTS)) && headerFormat="${headerFormat}${fs}%5s"
  headerFormat="${headerFormat}${fs}%5s${fs}%${fwTitle}s"
  ((PROdata)) && headerFormat="${headerFormat}${fs}%${fwArtist}s${fs}%${fwAlbum}s${fs}%${fwLabel}s${fs}%${fwPub}s"
  ((SCHEDCODES)) && headerFormat="${headerFormat}${fs}%s"
  # SC2059: the variable contains the printf format string.
  # shellcheck disable=SC2059
  printf "${headerFormat}\n" \
	 "Air Date" "Cart #" \
	 "$( ((INCLUDE_CUTS)) && print 'Cut #')" \
	 "Len" \
	 "Cart Title" \
	 $( ((PROdata)) && print "Artist\nAlbum\nLabel\nPublisher") \
	 $( ((SCHEDCODES)) && print "SchedCodes")
fi

# Find all matching events in ELR_LINES.
if okDatabaseStructure ELR_LINES:event_datetime+cut_number+artist+album+title+length+station_name,CART:number+group_name,CART_SCHED_CODES:sched_code ; then
  selectStatement="SELECT elr.event_datetime, elr.title, c.number, elr.length/1000"
  ((INCLUDE_CUTS)) && selectStatement="${selectStatement}, elr.cut_number"
  ((PROdata)) && selectStatement="${selectStatement}, elr.artist, elr.album, elr.label, elr.publisher"
  ((SCHEDCODES)) && selectStatement="${selectStatement}, csch.sched_code"
  selectStatement="${selectStatement} FROM ELR_LINES AS elr"
  selectStatement="${selectStatement} LEFT JOIN CART AS c on (elr.cart_number = c.number)"
  selectStatement="${selectStatement} ${schedCodesJoinClause}"
  selectStatement="${selectStatement} WHERE elr.cart_number IN"
  selectStatement="${selectStatement} (SELECT number FROM CART WHERE group_name ${whereClauseOp} '${group}' ${schedCodesAndClause})"
  selectStatement="${selectStatement} AND elr.service_name = '${service}'"
  selectStatement="${selectStatement} AND elr.station_name LIKE '${stationName}'"
  selectStatement="${selectStatement} AND elr.event_datetime > '${reportStartDate}'"
  selectStatement="${selectStatement} AND elr.event_datetime <= '${reportEndDate}'"
  selectStatement="${selectStatement} ORDER BY elr.event_datetime"
  ((VERBOSE > 1)) &&
    print "${0:t}: selectStatement: '${selectStatement}'" >&2
else
  print "${0:t}: Unknown database structure (multiple tables). Seek professional help." >&2
  exit 4
fi

typeset -A artist album label publisher

# Change input field separator (IFS) to just <Tab>.
oIFS="${IFS}"
IFS=$'\t'
# Output fields are <Tab>-separated.
doSQL "${selectStatement}" | while read -r line ; do
  # Because some fields might be the "empty string" and we don't like
  # that. And we do it twice because there might be two empty fields
  # in a row.
  line=$(print "${line}" | sed -e 's/\t\t/\tNA\t/g' -e 's/\t\t/\tNA\t/g')

  # Set the positional parameters to the fields in ${line}.
  set - $(print "${line}")
  airDateTime="${1}"
  cartTitle="${2}"
  cartNumber=${3}
  cartLength=${4}
  # Shift everything to the right by ${INCLUDE_CUTS} if --cuts was
  # specified on the command line.
  ((INCLUDE_CUTS)) && cutNumber=${(P)$((INCLUDE_CUTS + 4))}
  if ((PROdata)) ; then
    cartArtist="${(P)$((INCLUDE_CUTS + 5))}"
    cartAlbum="${(P)$((INCLUDE_CUTS + 6))}"
    cartLabel="${(P)$((INCLUDE_CUTS + 7))}"
    cartPublisher="${(P)$((INCLUDE_CUTS + 8))}"
  fi
  # Position of schedCodes is dependent on the --pro-data and the
  # --cuts options, also strip the trailing period (.) from the
  # database record.
  ((SCHEDCODES)) && schedCodes=${(P)$((5 + PROdata + INCLUDE_CUTS))%.}
  set -

  # Do not convert to MM:SS if we are in CSV mode.
  if ((CSV)) ; then
    cartMinSec=${cartLength}
  else
    cartMinSec=$(printf "%02d:%02d" $(( cartLength / 60 )) $(( cartLength % 60 )))
  fi

  # Insert a blank line between days.
  [[ "${airDateTime% *}" = "${lastAirDate}" ]] || print

  if ((CSV)) ; then
    printf "%s${fs}%d$( ((INCLUDE_CUTS)) && print ${fs}%d)${fs}%s${fs}%s$( ((${PROdata})) && echo ${fs}%s${fs}%s${fs}%s${fs}%s)$( ((${SCHEDCODES})) && echo ${fs}%s)\n" \
	   $(quote "${airDateTime}") \
	   "${cartNumber}" \
	   $( ((INCLUDE_CUTS)) && print "${cutNumber}") \
	   "${cartMinSec}" \
	   $(quote "${cartTitle}") \
	   $( ((${PROdata})) && quote "${cartArtist}") \
	   $( ((${PROdata})) && quote "${cartAlbum}") \
	   $( ((${PROdata})) && quote "${cartLabel}") \
	   $( ((${PROdata})) && quote "${cartPublisher}") \
	   $( ((${SCHEDCODES})) && getSchedCodes "${schedCodes}" "${fs}")
  else
    printf "%20s${fs}%06d$( ((INCLUDE_CUTS)) && print ${fs}%5d)${fs}%5s${fs}%${fwTitle}s${fs}%${fwArtist}s${fs}%${fwAlbum}s${fs}%${fwLabel}s${fs}%${fwPub}s\n" \
	   $(quote "${airDateTime}") \
	   ${cartNumber} \
	   $( ((INCLUDE_CUTS)) && print "${cutNumber}") \
	   ${cartMinSec} \
	   $(quote "${cartTitle}") \
	   $( ((${PROdata})) && quote "${cartArtist}") \
	   $( ((${PROdata})) && quote "${cartAlbum}") \
	   $( ((${PROdata})) && quote "${cartLabel}") \
	   $( ((${PROdata})) && quote "${cartPublisher}") \
	   $( ((${SCHEDCODES})) && getSchedCodes "${schedCodes}" "${fs}")
  fi

  # Save the meta data and the maximum field widths (we already know it for Title).
  title[${cartNumber}]="${cartTitle}"
  if (( PROdata )) ; then
    artist[${cartNumber}]="${cartArtist}"
    album[${cartNumber}]="${cartAlbum}"
    label[${cartNumber}]="${cartLabel}"
    publisher[${cartNumber}]="${cartPublisher}"
    schedcodes[${cartNumber}]="${schedCodes}"
  fi

  (( cartCount[${cartNumber}] += 1 ))

  lastAirDate=${airDateTime% *}

done

if ! ((CSV)) ; then
  # Restore the default value of ${IFS} in order to format the header.
  IFS="${oIFS}"

  print "\nPerformance Totals:"
  printf "%6s${fs}%3s${fs}%${fwTitle}s$( ((${PROdata})) && echo ${fs}%${fwArtist}s${fs}%${fwAlbum}s${fs}%${fwLabel}s${fs}%${fwPub}s)$( ((SCHEDCODES)) && echo ${fs}%s)\n" \
	 'Cart #' \
	 'Plays' \
	 'Cart Title' \
	 $( ((${PROdata})) && print -l Artist Album Label Publisher) \
	 $( ((SCHEDCODES)) && print SchedCodes)

  # set IFS back to a single <TAB> and a single newline
  IFS=$'\t\n'

  for cart in $(echo ${(k)cartCount} | ${TR} ' ' '\012' | ${SORT} -n) ; do
    printf "%06d${fs}%5d${fs}%${fwTitle}s$( ((${PROdata})) && echo ${fs}%${fwArtist}s${fs}%${fwAlbum}s${fs}%${fwLabel}s${fs}%${fwPub}s)$( ((${SCHEDCODES})) && echo ${fs}%s)\n" \
	   "${cart}" \
	   "${cartCount[${cart}]}" \
	   "${title[${cart}]}" \
	   $( ((${PROdata})) && print "${artist[${cart}]}") \
	   $( ((${PROdata})) && print "${album[${cart}]}") \
	   $( ((${PROdata})) && print "${label[${cart}]}") \
	   $( ((${PROdata})) && print "${publisher[${cart}]}") \
	   $( ((${SCHEDCODES})) && getSchedCodes "${schedcodes[${cart}]}" ", ")

  done
fi

exit

# Local Variables: ***
# mode:shell-script ***
# indent-tabs-mode: f ***
# sh-indentation: 2 ***
# sh-basic-offset: 2 ***
# sh-indent-for-do: 0 ***
# sh-indent-after-do: + ***
# sh-indent-comment: t ***
# sh-indent-after-case: + ***
# sh-indent-after-done: 0 ***
# sh-indent-after-else: + ***
# sh-indent-after-if: + ***
# sh-indent-after-loop-construct: + ***
# sh-indent-after-open: + ***
# sh-indent-after-switch: + ***
# sh-indent-for-case-alt: ++ ***
# sh-indent-for-case-label: + ***
# sh-indent-for-continuation: + ***
# sh-indent-for-done: 0 ***
# sh-indent-for-else: 0 ***
# sh-indent-for-fi: 0 ***
# sh-indent-for-then: 0 ***
# End: ***
