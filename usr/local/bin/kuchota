#!/bin/zsh

##########################################################################################
##########################################################################################
##
##
## kuchota (Swahili for "fetch")
##
## A PMW podget tool to manage podcast feeds (i.e., RSS, ATOM, etc.)
## and downloads by podget(1), for later import into a Rivendell
## library.
##
##########################################################################################
##########################################################################################

setopt REMATCH_PCRE
setopt NO_CASE_MATCH
zmodload zsh/regex
zmodload zsh/datetime
zmodload zsh/terminfo
zmodload zsh/stat
autoload colors
colors

# This script complies with Semantic Versioning: http://semver.org/
vMajor=0
vMinor=1
vPatch=3
vHash='$Hash$'

# Get zsh functions necessary for this script.
if [[ -r ${ROOT:-/}usr/local/bin/zsh-functions ]] ; then
  source ${ROOT:-/}usr/local/bin/zsh-functions
else
  exit $(error "Cannot read support library '${ROOT:-/}usr/local/bin/zsh-functions'. Please consult your tarot card reader!")
fi

##########################################################################################
## Locally defined subroutines
##########################################################################################

# How to use this command.
usage() {
  myName=${1}

  ${CAT} << EOF
${myName}: add a new RSS feed to the list of podcasts.

Summary: ${myName##*/} [ --verbose (-v) ] [ --version (-V) ]
                       [ --config (-c) <podget_configuration_file> ]
                       [ --dir_config (-d) <podget_configuration_directory> ]
                       [ --group (-g) { <Rivendell Group Name> or 'list' } ]

You may use the word "list" for the --group (-g) option.
This will cause ${myName##*/} to list the available groups and
prompt you for which one to use for this podcast.

EOF
}

addOrReplaceFeed() {
  local myName=${1} ; shift
  local verbose=${1}

  local feedURL feedUser feedPassword protocol hostANDport route urlWithCredentials titleParserXSL
  local feedTitle name group rivendellGroupList
  local backupServerlist=${ROOT:-/}var/tmp/${CONFIG_SERVERLIST##*/}
  local replaceFeed=0 addNewFeed=1
  local ok

  trap 'trap - ; return ;' 0 1 2 3

  # Make a backup copy of serverlist before we make any changes.
  ${CP} ${DIR_CONFIG}/${CONFIG_SERVERLIST} ${backupServerlist}

  read feedURL\?"Type or paste the RSS feed URL for this podcast: "

  if read -q ok\?"Does this podcast download require a username? [y,N] " ; then
    echo
    read feedUser\?"Enter the feed username: "

    if read -q ok\?"Does this URL require a password for the user ${feedUser}? [y,N] " ; then
      echo
      read feedPassword\?"Enter the password for the user ${feedUser}: "
    fi

    protocol=${feedURL%://*}
    hostANDport=${${feedURL#${protocol}://}%%/*}
    route=${feedURL#${protocol}://${hostANDport}}

    # ${urlWithCredentials} is used below only to try to obtain the feed title.
    urlWithCredentials=${protocol}://${feedUser}${feedPassword:+:${feedPassword}}@${hostANDport}/${route}
  fi
  echo

  titleParserXSL=$(makeParser /rss/channel/title)
  trap "${RM} -f ${titleParserXSL} ; trap - ; return ;" 0 1 2 3

  ##########################################################################################
  ## Get the feed title, either by its own XML (with xsltproc), or by
  ## brute force with (wget). This code snippet and the XSL parser
  ## snippet lifted from bashpodder, http://www.lincgeek.org/bashpodder/
  ## (link retrieved Tue Aug 9 11:27:36 CDT 2016)
  ##########################################################################################
  feedTitle=$(${XSLTPROC} ${titleParserXSL} "${urlWithCredentials:-${feedURL}}" 2>/dev/null ||
		 ${WGET} -q "${urlWithCredentials:-${feedURL}}" -O - | ${GREP} -m 1 '<title>' | ${SED} -e 's,^ *<title>\(.*\)</title>.*$,\1,')
  if [[ -z "${feedTitle}" ]] ; then

    # Try it without the username and password.
    if [[ -n "${urlWithCredentials}" ]] ; then

      feedTitle=$(${XSLTPROC} ${titleParserXSL} "${feedURL}" 2>/dev/null ||
		     ${WGET} -q "${feedURL}" -O - | ${GREP} -m 1 '<title>' | ${SED} -e 's,^ *<title>\(.*\)</title>.*$,\1,')

    else

      warning "I could not discern the title for this feed. Please make sure the URL, username (if needed) and password (if needed) are correct and if necessary, re-run ${myName}."

    fi
  fi

  ${RM} -f ${titleParserXSL}
  trap 'trap - ; return ;' 0 1 2 3

  ##########################################################################################
  ## Prompt for a name, use the feed title previously obtained if the
  ## user does not enter anything.
  ##########################################################################################
  read name\?"Enter a name for this podcast (${BOLD}Note: I may do some manipulation of the name${NORM}): ${feedTitle:+[${feedTitle}]} "
  [[ -z "${name}" ]] && name=${feedTitle}
  # From the inside out, this parameter substitution does the following:
  #    converts ":", "<Space>", ",", and "!" to a dash ("-")
  #    deletes single (') and double (") quotes
  #    converts double-dash ("--") to single dash ("-")
  #    deletes a single dash ("-") at the end of the string
  read -q ok\?"Using ${${${${name//[: ,\!)(]/-}//[\"\']/}//--/-}/%-/} for the podcast name. OK? [y,N]: "
  until [[ ${ok} =~ [Yy] ]] ; do

    echo
    read name\?"OK, try again. Enter a name for this podcast: "
    read -q ok\?"Using '${${${${name//[: ,\!)(]/-}//[\"\']/}//--/-}/%-/}' for the podcast name. OK? [y,N]: "

  done
  feedName="${${${${name//[: ,\!)(]/-}//[\"\']/}//--/-}/%-/}"

  ##########################################################################################
  ## Get the "category" for this podcast. Use a Rivendell GROUP for the category name.
  ##########################################################################################
  # See zsh-functions for the definition of doSQL.
  rivendellGroupList=$(doSQL "select NAME from GROUPS order by NAME")

  # List the groups and prompt them for a group to use if they asked for
  # a list or if they did not name a group.
  if [[ -z "${group}" ]] || [[ "${group}" =~ 'list' ]] ; then

    echo "\nCurrent list of GROUPs:"
    ${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) <<< ${rivendellGroupList}
    read group\?"Type the name of the Rivendell GROUP into which this podcast will be imported: "

  fi

  # Validate the group against the current known list of groups in the
  # Rivendell database.
  until ${GREP} -q "^${group}$" <<< ${rivendellGroupList} ; do

    warning "'${group}' is not in the list. Please use a valid GROUP name."

    echo "Current list of GROUPs:"
    ${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) <<< ${rivendellGroupList}
    read group\?"Enter the Rivendell GROUP into which this podcast will be imported: "

  done

  (( verbose )) && echo ${feedURL} ${group} ${feedName}${feedUser:+" USER:${feedUser}"}${feedPassword:+" PASS:${feedPassword}"}

  [[ -w ${DIR_CONFIG}/${CONFIG_SERVERLIST} ]] ||
    return $(error "Missing access rights to modify the file ${DIR_CONFIG}/${CONFIG_SERVERLIST}")

  local tmpfile=$(${MKTEMP})
  trap "${RM} -f ${tmpfile}; trap - ; return ;" 0 1 2 3

  # Same group and name (possibly different URL?).
  if ${GREP} -P -q "^[^#].*\s+${group}\s+${feedName}\s*" ${DIR_CONFIG}/${CONFIG_SERVERLIST} ; then

    addNewFeed=0
    if read -q ok\?"${feedName} already exists in group ${group}. Replace? [y,N] " ; then

      ${GREP} -P -v "^[^#].*\s+${group}\s+${feedName}\s*" ${DIR_CONFIG}/${CONFIG_SERVERLIST} > ${tmpfile}
      replaceFeed=1

    fi

  # Same name, different group.
  elif ${GREP} -P -q "^[^#].*\s+${feedName}\s*" ${DIR_CONFIG}/${CONFIG_SERVERLIST} ; then

    addNewFeed=0
    if read -q ok\?"${feedName} already exists in a different group. Change to group '${group}'? [y,N] " ; then

      ${GREP} -P -v "^[^#].*\s+${feedName}\s*" ${DIR_CONFIG}/${CONFIG_SERVERLIST} > ${tmpfile}
      replaceFeed=1

    fi
  fi

  if (( addNewFeed || ! replaceFeed )) ; then

    # A new feed.
    ${CP} ${DIR_CONFIG}/${CONFIG_SERVERLIST} ${tmpfile}

  fi

  if (( addNewFeed || replaceFeed )) ; then

      ${CAT} <<EOF >> ${tmpfile}
${feedURL} ${group} ${feedName}${feedUser:+" USER:${feedUser}"}${feedPassword:+" PASS:${feedPassword}"}
EOF

  fi

  if [[ -s ${tmpfile} ]] ; then

    # There should be no more than two lines of difference between the
    # original and the edited file.
    if (( $(${DIFF} --side-by-side --suppress-common-lines ${DIR_CONFIG}/${CONFIG_SERVERLIST} ${tmpfile} | ${WC} -l) <= 2 )) ; then

      # We made a tmpfile, so replace serverlist with its contents.
      ${MV} ${tmpfile} ${DIR_CONFIG}/${CONFIG_SERVERLIST} ||
	return $(error "Could not replace ${DIR_CONFIG}/${CONFIG_SERVERLIST}.")

      ${CHMOD} 644 ${DIR_CONFIG}/${CONFIG_SERVERLIST}

      ${MKDIR} -p ${DIR_LIBRARY}/${group}/${feedName} ||
	warning "Failed to create new podcast directory ${DIR_LIBRARY}/${group}/${feedName} (${?}). You may have to create this yourself."

      echo

      # Offer to create a Rivendell dropbox if we are making changes
      # to this podcast (new or replace).
      if addRDDropbox ${myName} ${DIR_LIBRARY} ${feedName} ${group} ${verbose} ; then

	# Second arg indicates we are calling rdDropboxStatus interactively.
	rdDropboxStatus ${myName} 1 ${verbose}

      fi

      read ok\?"Podcast $( (( replaceFeed )) && echo replaced || echo added). Press <Enter> to continue. "

    else

      returnValue=$(error "Found an unexpected error in the new podcast feed file while attempting to add '${feedName}'")
      echo "Restoring backup. Please notify the authorities!"

      (( verbose )) && ${DIFF} --side-by-side --suppress-common-lines ${DIR_CONFIG}/${CONFIG_SERVERLIST} ${tmpfile}
      ${MV} ${backupServerlist} ${DIR_CONFIG}/${CONFIG_SERVERLIST}

      read ok\?"Press <Enter> to continue. "

    fi

  else

    returnValue=$(error "Found an empty podcast feed file while attempting to add feed '${feedName}'")
    echo "Restoring backup. Please notify the authorities!"

    ${MV} ${backupServerlist} ${DIR_CONFIG}/${CONFIG_SERVERLIST}

    read ok\?"Press <Enter> to continue. "

  fi

  trap -
}

enableFeed() {
  local myName=${1} ; shift
  local verbose=${1}

  local feedList feedNameEntered feedName group tmpfile

  trap 'trap - 0 1 2 3 ; return ;' 0 1 2 3

  feedList=$(${GREP} '^#DISABLED#' ${DIR_CONFIG}/${CONFIG_SERVERLIST} | ${AWK} '{print $3}')

  # Try to enable feeds only if there actually are any disabled ones.
  if [[ -n "${feedList}" ]] ; then

    if (( $(${WC} -l <<<${feedList}) > 1 )) ; then

      echo "Current list of disabled podcast feeds:"
      ${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) <<< ${feedList}
      read feedNameEntered\?"Enter the name of the podcast ('*' wildcard OK) you want to enable (and press <Enter>): "

      # Allow '*'-style wildcards in the feedName, will expand it below.
      until feedName=$(${GREP} "^${feedNameEntered//\*/.*}$" <<< ${feedList}) ; do

	warning "'${feedNameEntered}' is not in the list. Please use a valid feed name."

	echo "Current list of disabled podcast feeds:"
	${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) <<< ${feedList}
	read feedNameEntered\?"Type or paste the name of the podcast ('*' wildcard OK) you want to enable: "

      done

    else

      # There is only one feed to enable, so do not bother prompting for it.
      feedName=${feedList}

    fi

    echo "Enabling '${feedName}' in the feed list... \c"

    trap "${RM} -f ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak ; trap - ; return ;" 0 1 2 3

    ${SED} -i.bak -e "/^#DISABLED#.*[[:space:]]${feedName}[[:space:]]*/s/^#DISABLED#//" ${DIR_CONFIG}/${CONFIG_SERVERLIST}
    # The sed command *should* result in exactly one line of
    # difference between the original and the edited file.
    if (( $(${DIFF} --side-by-side --suppress-common-lines ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak ${DIR_CONFIG}/${CONFIG_SERVERLIST} | ${WC} -l) == 1 )) ; then

      ${RM} -f ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak

      if [[ ! -d ${DIR_LIBRARY}/${group}/${feedName} ]] ; then
	${MKDIR} -p ${DIR_LIBRARY}/${group}/${feedName} ||
	  warning "Failed to create new podcast directory ${DIR_LIBRARY}/${group}/${feedName} (${?}). You may have to create this yourself."
      fi

      group=$(${AWK} "/[[:space:]]${feedName}[[:space:]]*/{print \$2}" ${DIR_CONFIG}/${CONFIG_SERVERLIST})

      # Offer to create a Rivendell dropbox if we are making changes
      # to this podcast (new or replace).
      if addRDDropbox ${myName} ${DIR_LIBRARY} ${feedName} ${group} ${verbose} ; then

	# Second arg indicates we are calling rdDropboxStatus interactively.
	rdDropboxStatus ${myName} 1 ${verbose}

      fi
      echo "Done."

    else

      warning "Could not properly enable the disabled podcast feed '${feedName}'.
Please fix the file '${DIR_CONFIG}/${CONFIG_SERVERLIST}' manually."

      ${RM} -f ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak

    fi

    read ok\?"Press <Enter> to continue. "

  else

    read ok\?"There are no disabled feeds available. Press <Enter> to continue. "

  fi

  trap -
}

deleteFeed() {
  local myName=${1} ; shift
  local verbose=${1}

  local feedList feedNameEntered feedName deleteOrDisable tmpfile group

  trap 'trap - ; return ;' 0 1 2 3

  feedList=$(${GREP} -v '^#' ${DIR_CONFIG}/${CONFIG_SERVERLIST} | ${AWK} '{print $3}')

  # Delete feeds only if there actually are any available.
  if [[ -n "${feedList}" ]] ; then

    # Prompt for a feed to delete only if there is more than one in
    # the list.
    if (( $(${WC} -l <<<${feedList}) > 1 )) ; then

      echo "Current list of podcast feeds:"
      ${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) <<< ${feedList}
      read feedNameEntered\?"Enter the name of the podcast ('*' wildcard OK) you want to delete or disable (and press <Enter>): "

      until feedName=$(${GREP} "^${feedNameEntered//\*/.*}$" <<< ${feedList}) ; do

	warning "'${feedNameEntered}' is not in the list. Please use a valid feed name."

	echo "Current list of podcast feeds:"
	${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) <<< ${feedList}
	read feedNameEntered\?"Enter the name of the podcast ('*' wildcard OK) you want to delete or disable: "

      done

    else

      # Only one feed, so offer it for deletion.
      feedName=${feedList}

    fi

    group=$(${AWK} "/[[:space:]]${feedName}[[:space:]]*/{print \$2}" ${DIR_CONFIG}/${CONFIG_SERVERLIST})
    (( verbose )) && warning "${myName}: deleting from group '${group}'."

    read -k 1 deleteOrDisable\?"Do you want to disable (d) or delete (D) '${feedName}'? "
    until [[ "${deleteOrDisable}" =~ '[Dd]' ]] ; do
      echo
      read -k 1 deleteOrDisable\?"Please type a lower case 'd' for 'disable' or an upper case 'D' for 'delete' "
    done
    echo

    if [[ "${deleteOrDisable}" = 'd' ]] ; then

      echo "Disabling '${feedName}' in the feed list... \c"

      trap "${RM} -f ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak ; trap - ; return ;" 0 1 2 3

      ${SED} -i.bak -e "/[[:space:]]${feedName}[[:space:]]*/s/^/#DISABLED#/" ${DIR_CONFIG}/${CONFIG_SERVERLIST}
      # The sed command *should* result in exactly one line of
      # difference between the original and the edited file.
      if (( $(${DIFF} --side-by-side --suppress-common-lines ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak ${DIR_CONFIG}/${CONFIG_SERVERLIST} | ${WC} -l) == 1 )) ; then

	${RM} -f ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak

	if cleanupFeed ${myName} ${group} ${feedName} ${verbose} ; then

	  if deleteRDDropbox ${myName} ${DIR_LIBRARY}/${group}/${feedName} ${verbose} ; then

	    echo "Purged dropbox for feed '${feedName}'."

	  else

	    warning "Unable to successfully delete the dropbox for feed '${feedName}'. Please consult with a professional."

	  fi
	  echo "Done."

	else

	  warning "Unable to successfully clean up the cruft lying about for feed '${feedName}' (${?}). Please report this number to the authorities."

	fi

      else

	warning "Could not properly disable the podcast feed '${feedName}'. Please fix the file '${DIR_CONFIG}/${CONFIG_SERVERLIST}' manually."

	${RM} -f ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak

      fi

      trap 'trap - ; return ;' 0 1 2 3

    elif [[ "${deleteOrDisable}" = 'D' ]] ; then

      echo "Deleting feed '${feedName}' from the feed list... \c"

      tmpfile=$(${MKTEMP})
      trap "${RM} -f ${tmpfile}; trap - ; return ;" 0 1 2 3

      ${GREP} -v "[[:space:]]${feedName}[[:space:]]*" ${DIR_CONFIG}/${CONFIG_SERVERLIST} > ${tmpfile}

      if [[ -s ${tmpfile} ]] ; then

	if ${MV} ${tmpfile} ${DIR_CONFIG}/${CONFIG_SERVERLIST} ; then

	  echo "Done."

	  if read -q ok\?"Do you want to delete the dropbox for this feed too? [y,N] " ; then

	    echo
	    if cleanupFeed ${myName} ${group} ${feedName} ${verbose} ; then

	      if deleteRDDropbox ${myName} ${DIR_LIBRARY}/${group}/${feedName} ${verbose} ; then

		echo "Purged dropbox for feed '${feedName}'."

	      else

		warning "Unable to successfully delete the dropbox for feed '${feedName}'. Please consult with a professional."

	      fi

	    else

	      warning "Unable to successfully clean up the cruft lying about for feed '${feedName}' (${?}). Please report this number to the authorities."

	    fi

	  else

	    echo "\nOK. Not deleting the dropbox for feed '${feedName}'."

	  fi

	else

	  warning "Could not replace '${DIR_CONFIG}/${CONFIG_SERVERLIST}' with the deleted podcast feed. Do you have the access rights to replace this file? Please fix the file '${DIR_CONFIG}/${CONFIG_SERVERLIST}' manually."

	fi
      else

	warning "Unable to find '${feedName}' in ${DIR_CONFIG}/${CONFIG_SERVERLIST}. Please fix the file ${DIR_CONFIG}/${CONFIG_SERVERLIST} manually."

      fi

    else

      echo "\nWTF? How did you get past the prompt without entering a 'd' or a 'D'?"

    fi

    trap 'trap - ; return ;' 0 1 2 3

    read ok\?"Press <Enter> to continue. "

  else

    read ok\?"There are no feeds available to delete. Press <Enter> to continue. "

  fi

  trap -
}

listFeeds() {
  local myName=${1} ; shift
  local verbose=${1}

  trap 'trap - ; return ;' 0 1 2 3

  (
    # The header.
    reportTitleText="Kuchota Podcasts"
    reportTitle="$(printf ' %.0s' {1..$(( ( ${terminfo[cols]} - ${#reportTitleText} ) / 2 ))})${reportTitleText}"
    printf ' '; printf '=%.0s' {1..$(( ${terminfo[cols]} - 2 ))} ; print
    print "${reportTitle}"
    printf ' '; printf '=%.0s' {1..$(( ${terminfo[cols]} - 2 ))} ; print
    printf '%-46s %-16s %-48s\n'  "Title" "Group" "Credentials"
    printf '-%.0s' {1..46}; printf '-%.0s' {1..16}; printf '-%.0s' {1..48}; print

    # The content.
    ${SED} -e '1,/^# ---------/d' < ${DIR_CONFIG}/${CONFIG_SERVERLIST} |
      ${GREP} -v '^ *$' |
      ${SORT} --ignore-case --key=3,3 --key=2,2 |
      while read url group title rest ; do
	if [[ ${url} =~ '#DISABLED#.*' ]] ; then
	  title="${RED}DISABLED:${NORM} ${title}"
	  url="${RED}DISABLED:${NORM} ${url/\#DISABLED#/}"
	fi
	rdDropBoxPath="${DIR_LIBRARY}/${group}/${title}/*.mp3"
	printf '%-46s %-16s %-48s\n%-80s\nRD DropBox: %-80s\n\n' ${title} ${group} ${rest:-""} ${url} "${rdDropBoxPath//${RED}DISABLED:${NORM} }"
      done

    # The footer.
    printf ' '; printf '=%.0s' {1..$(( ${terminfo[cols]} - 2 ))} ; print
  ) | ${LESS} -RCiP "Viewing podcast feeds?e (End of Output).\. Press <q> to quit, <PgDown> and <PgUP> to scroll\."

  trap -
}

showLastStatus() {
  local myName=${1} ; shift
  local type=${1} ; shift
  local verbose=${1}

  local statusFile=${STATUS_FILE:-${ROOT:-/}var/tmp/pmw-podget-wrapper.${type}}
  local fileTime

  trap 'trap - ; return ;' 0 1 2 3

  case ${type} in
    out) OUTPUT="output results" ;;
    err) OUTPUT="diagnostic output" ;;
  esac

  if zstat -H statusStat ${statusFile} ; then
    fileTime=$(strftime "%A, %B %d, %Y at %T" ${statusStat[mtime]})
  fi

  (
    # The header.
    reportTitleText="Latest Kuchota 'podget' ${(C)OUTPUT}"
    if [[ -n "${fileTime}" ]] ; then
      reportTitleText="${reportTitleText} as of ${fileTime}"
    fi
    # Center the title on the display.
    reportTitle="$(printf ' %.0s' {1..$(( ( ${terminfo[cols]} - ${#reportTitleText} ) / 2 ))})${reportTitleText}"
    printf ' '; printf '=%.0s' {1..$(( ${terminfo[cols]} - 2 ))} ; print
    print "${reportTitle}"
    printf ' '; printf '=%.0s' {1..$(( ${terminfo[cols]} - 2 ))} ; print

    # The data.
    ${CAT} ${statusFile}

    # The footer.
    printf ' '; printf '=%.0s' {1..$(( ${terminfo[cols]} - 2 ))} ; print
  ) | ${LESS} -RCiP "Viewing the latest podget ${OUTPUT}?e (End of Output).\. Press <q> to quit, <PgDown> and <PgUP> to scroll\."

  trap -
}

editSchedule() {
  local myName=${1} ; shift
  local verbose=${1}

  local minute oMinute hour oHour crontab answer ok

  trap 'trap - ; return ;' 0 1 2 3

  # Snag the current crontab for later processing.
  crontab=$(${CRONTAB} -l)

  # Give them the opportunity to change the existing schedule.
  if ${GREP} -q 'pmw-podget-wrapper' <<<"${crontab:-X}" ; then

    ${CAT} <<EOF

The current schedule for downloading podcasts is as follows. This is
the entire crontab entry. '${BOLD}pmw-podget-wraper${NORM}' is the tool used to
launch and track '${BOLD}podget${NORM}', the downloader app.

${BOLD}$(${GREP} 'podget-wrapper' <<<${crontab})${NORM}

EOF

    if ! read -q change\?"Do you want to change the schedule? [y,N] " ; then

      echo "\nLeaving the download schedule as it is."
      read ok\?"Press <Enter> to continue. "
      trap -
      return

    fi

    # Pre-fill the vailues we will later prompt for.
    minute=$(${AWK} '/^[^#].*podget-wrapper/{print $1}' <<<${crontab})
    hour=$(${AWK} '/^[^#].*podget-wrapper/{print $2}' <<<${crontab})

  fi

  ${CAT} <<EOF


${(C)myName} runs the 'pmw-podget-wrapper' backend periodically in
order to check for new episodes of podcasts. I check all podcasts
each time, downloading new episodes for each podcast as they appear.

Typically, 'pmw-podget-wrapper' runs from cron at least once an hour
every day. I'll assume you want to do that. You will need to update
the cron job manually (using the 'crontab' command) only if you want a
different schedule.

Valid hours are 0 - 23 and '*'.

EOF

  until [[ "${ok}" =~ '[Yy]' ]] ; do

    oHour=${hour}
    read hour\?"Type the hour(s) you want ${myName} to check for new podcasts (enter '*' for every hour): ${hour:+[${hour}] }"
    [[ -z "${hour}" ]] && hour=${oHour}
    until [[ "${hour}" =~ '^(\*|[[:digit:],]+)$' ]] ; do

      echo "You need to enter either an asterisk ('*'), or some combination of hour numbers and commas."
      read hour\?"Type the hour(s) you want ${myName} to check for new podcasts (enter '*' for every hour): "

    done

    ${CAT} <<EOF

Now I need to know how many times an hour you want to check for new
podcasts. You can enter a single "minute" representing once an hour,
or you can enter multiple minutes separated with commas (','). Valid
minutes are 0 - 59.

EOF

    oMinute=${minute}
    read minute\?"Enter the minute(s) of the hour(s) ('${hour}') you want to check for podcasts: ${minute:+[${minute}] }"
    [[ -z "${minute}" ]] && minute=${oMinute}
    until [[ "${minute}" =~ '^[[:digit:],]+$' ]] ; do

      echo "You need to enter combination of minute numbers and commas."
      read minute\?"Type the minute(s) of the hour(s) ('${hour}') you want to check for podcasts: "

    done

    echo "Using 'hour: ${hour}' and 'minute: ${minute}' for the podcast download schedule."

    if ! read -q ok\?"Press 'y' to commit this schedule, or 'n' to cancel (you will have to start over): " ; then
      echo "\nCanceling this schedule change. Please try your call again later."
      read ok\?"Press <Enter> to continue. "
      trap -
      return
    fi

  done

  (
    ${GREP} -v 'pmw-podget-wrapper' <<<${crontab}
    echo "${minute} ${hour} * * * zsh /usr/local/bin/pmw-podget-wrapper"
  ) | ${CRONTAB} -

  ${CAT} <<EOF

Here is the complete cron entry for downloading podcasts:

$(${CRONTAB} -l | ${GREP} --perl-regexp '^(#|.*podget-wrapper)')

EOF

  trap -
}

editFile() {
  local myName=${1} ; shift
  local filename=${1} ; shift
  local verbose=${1}

  trap 'trap - ; return ;' 0 1 2 3

  ${VISUAL:-${EDITOR:-nano}} ${filename}

  trap -
}

cronEdit() {
  local myName=${1} ; shift
  local verbose=${1}

  trap 'trap - ; return ;' 0 1 2 3

  EDITOR=${VISUAL:-${EDITOR:-nano}} ${CRONTAB} -e

  trap -
}

addRDDropbox() {
  local myName=${1} ; shift
  local dirLibrary=${1} ; shift
  local feedName=${1} ; shift
  local feedGroup=${1} ; shift
  local verbose=${1}

  local createANewDropbox=0
  local returnValue=1

  if (( rdDBVersionCompatible != $(rdDatabaseVersion) )) ; then

    return $(error "This version of ${myName} is not compatible with Rivendell database version '$(rdDatabaseVersion)'. You need to create a dropbox manually.")

  fi

  # See whether there is a dropbox with a matching pathname.
  query="select d.ID,d.PATH,d.TO_CART,d.GROUP_NAME from DROPBOXES d where d.PATH like '${DIR_LIBRARY}/${feedGroup}/${feedName}/%'"
  read dropboxID dropboxPATH dropboxCARTNUM dropboxGROUP <<<$(doSQL "${query}")
  if (( dropboxID )) ; then

    info="It appears as if Rivendell dropbox '${dropboxID}' watches for files at '${dropboxPATH}'."

    if (( dropboxCARTNUM )) ; then

      query="select TITLE from CART where NUMBER = ${dropboxCARTNUM}"
      read cartTITLE <<<$(doSQL "${query}")

      info="${info} The dropbox uses the CART '${cartTITLE}' (number ${dropboxCARTNUM})."

      ${FMT} <<<${info}

    else

      info="${info} This dropbox assigns new carts in group '${dropboxGROUP}'."

      ${FMT} <<<${info}

    fi

    if read -q answer\?"Do you want to use this dropbox for the feed '${feedName}'? [y,N] " ; then

      echo "\nOK, using existing dropbox."
      returnValue=0

    else

      echo "\nOK, creating a new dropbox for feed '${feedName}'."
      createANewDropbox=1

    fi
  else
    createANewDropbox=1
  fi

  if (( createANewDropbox )) ; then

    if read -q answer\?"Would you like to set up a Rivendell dropbox for '${feedName}'? [y,N] " ; then

      echo
      if read -q answer\?"Create a new CART and assign each podcast episode to it (one CART for all episodes)? [y,N] " ; then

	echo
	if dropboxID=$(createDropbox ${feedGroup} ${feedName} ${DIR_LIBRARY} ${fileExt} $(rdCreateEmptyCart ${feedGroup} ${feedName}) ${verbose}) ; then
	  echo "Dropbox number ${dropboxID} created."
	  returnValue=0
	else
	  warning "Error creating dropbox for feed '${feedName}'. Please notify the authorities!"
	fi
      else

	echo
	if read -q answer\?"OK, do you want each new episode of '${feedName}' to be placed into its own new cart? [y,N] " ; then

	  echo
	  if dropboxID=$(createDropbox ${feedGroup} ${feedName} ${DIR_LIBRARY} ${fileExt} 0 ${verbose}) ; then
	    echo "Dropbox number ${dropboxID} created."
	    returnValue=0
	  else
	    warning "Error creating dropbox for feed '${feedName}'. Seek professional help!"
	  fi
	else

	  ${FMT} <<EOF

Well, you're not assigning a specific cart to this podcast, and you're not using a new cart for each episode. You're on your own.

EOF

	fi
      fi
    else

      echo
      echo "\nOK, but you may want to add a Rivendell dropbox on your own."

    fi
  fi

  return ${returnValue}
}

showRDDropboxes() {
  local myName=${1} ; shift
  local verbose=${1}

  local query="select d.ID,d.PATH,d.GROUP_NAME,d.TO_CART,c.TITLE from DROPBOXES d left join CART c on (d.TO_CART = c.NUMBER) where d.PATH like '${DIR_LIBRARY}/%'"
  local id path group cart title

  trap 'trap - 0 1 2 3 ; return ;' 0 1 2 3

  if (( rdDBVersionCompatible != $(rdDatabaseVersion) )) ; then

    return $(error "This version of ${myName} is not compatible with Rivendell database version '$(rdDatabaseVersion)'. You need to create a dropbox manually.")

  fi

  (
    # The header.
    reportTitleText="Kuchota-related (not all) Rivendell Dropboxes"
    reportTitle="$(printf ' %.0s' {1..$(( ( ${terminfo[cols]} - ${#reportTitleText} ) / 2 ))})${reportTitleText}"
    printf ' '; printf '=%.0s' {1..$(( ${terminfo[cols]} - 2 ))} ; print
    print "${reportTitle}"
    printf ' '; printf '=%.0s' {1..$(( ${terminfo[cols]} - 2 ))} ; print
    printf '%3s %-64s %-12s %6s %-32s\n'  "ID" "Dropbox Path Spec" "Group" "CART #" "Title"
    printf '-%.0s' {1..$((4+65+13+7+32))}; print

    # The data.
    doSQL "${query}" | while read id path group cart title ; do

      if (( cart == 0 )) ; then
	title='** New cart for each episode **'
      fi

      printf '%3d %-64s %-12s %06d %-32s\n' ${id} ${path} ${group} ${cart} ${title}

    done

    # The footer.
    printf ' '; printf '=%.0s' {1..$(( ${terminfo[cols]} - 2 ))} ; print

  ) | ${LESS} -RCiP "Viewing Rivendell Dropboxes for Kuchota?e (End of Output).\. Press <q> to quit, <PgDown> and <PgUP> to scroll\."

  trap -
}

showDropboxStatus() {
  local myName=${1} ; shift
  local verbose=${1}

  local ok

  # Second arg indicates we are calling rdDropboxStatus interactively.
  rdDropboxStatus ${myName} 1 ${verbose}

  echo
  read ok\?"Press <Enter> to continue. "
}

deleteRDDropbox() {
  local myName=${1} ; shift
  local pathPrefix=${1} ; shift
  local verbose=${1}

  local returnValue=0

  if (( rdDBVersionCompatible != $(rdDatabaseVersion) )) ; then

    return $(error "This version of ${myName} is not compatible with Rivendell database version '$(rdDatabaseVersion)'. You need to delete the dropbox manually.")

  fi

  query="select ID,PATH,TO_CART from DROPBOXES where PATH like '${pathPrefix}%'"
  read id path cart <<<$(doSQL "${query}")
  if (( cart )) ; then
    cartText="and imports the audio into CART ${cart}"
  else
    cartText="and creates a new cart for each episode"
  fi

  ${FMT} <<EOF

About to delete the Rivendell dropbox ID '${id}' which watches for files at '${path}', ${cartText}.

EOF

  if read -q ok\?"Type 'y' to proceed, or 'n' to cancel: " ; then

    query="delete from DROPBOXES where ID = ${id}"
    doSQL "${query}"

    query="select ID from DROPBOXES where ID = ${id}"
    result=$(doSQL "${query}")
    if [[ -z "${result}" ]] ; then

      echo "\nDropbox '${id}' successfully deleted"

    else

      echo "\nHmmmm... That dropbox (ID '${id}') is still in the Rivendell database. You should figure out what's going on."
      returnValue=1

    fi

  else

    echo "\nAlright, but you will need to delete that dropbox yourself."

  fi

  return ${returnValue}
}

cleanupFeed() {
  local myName=${1} ; shift
  local group=${1} ; shift
  local feedName=${1} ; shift
  local verbose=${1}

  local pathPrefix=${DIR_LIBRARY}/${group}/${feedName}

  local id
  local returnValue=0

  (( verbose )) && warning "${myName}: pathPrefix is '${pathPrefix}'."

  if id=$(rdGetDropboxIDFromPath ${myName} ${pathPrefix} ${verbose}) ; then

    rdimportPID=$(for PID in $(${PIDOF} rdimport) ; do
		    ${GREP} -q --text "persistent-dropbox-id=${id}" /proc/${PID}/cmdline &&
		      { echo ${PID} ; break ; }
		  done)
    if [[ -n "${rdimportPID}" ]] && ${KILL} ${rdimportPID} ; then

      if [[ -d ${pathPrefix} ]] ; then

	${RM} -rf ${pathPrefix}

      else

	warning "Dropbox path '${pathPrefix}' is not a directory. Please seek professional help."
	returnValue=3

      fi

    else

      warning "Unable to kill process '${rdimportPID}'."
      returnValue=2

    fi

  else

    warning "ID returned from rdGetDropboxIDFromPath() was '${id}' for path '${pathPrefix}'."
    returnValue=1

  fi

  return ${returnValue}
}

makeParser() {
  local selection=${1:?"Need an XML selection."}
  local tempfile=$(${MKTEMP})
  
  ${CAT} > ${tempfile} <<EOF
<?xml version="1.0"?>
<stylesheet version="1.0"
	xmlns="http://www.w3.org/1999/XSL/Transform">
	<output method="text"/>
	<template match="/">
		<apply-templates select="${selection}"/>
	</template>
	<template match="enclosure">
		<value-of select="@url"/><text>&#10;</text>
	</template>
</stylesheet>
EOF

  echo ${tempfile}
}

createDropbox() {
  local feedGroup=${1:?"Need a Rivendell GROUP to assign to this dropbox."} ; shift
  local feedName=${1:?"Need a podcast feed name for this dropbox."} ; shift
  local dirLibrary=${1:?"Need a DIR_LIBRARY for this dropbox."} ; shift
  local fileExt=${1:?"Need a file extension (type) for this dropbox."} ; shift
  local cartNumber=${1:?"Need a CART number for this dropbox."} ; shift
  local verbose=${1}

  local dropboxPath="${dirLibrary}/${feedGroup}/${feedName}"
  local returnValue=0
  local deleteCuts stationName dropboxID
  local -a query

  ## DELETE_CUTS defaults to "N" in the database if they simply press
  ## <Enter> in response to this prompt.
  echo >&2
  read -q deleteCuts\?"Do you want to delete old cuts before importing new audio for this dropbox? [y,N] "
  echo >&2

  if stationName=$(rdGetStationName) ; then

    ## This shell array variable gets turned into a single string below.
    query=(
      "insert into DROPBOXES"
      "(STATION_NAME, GROUP_NAME, PATH, NORMALIZATION_LEVEL, AUTOTRIM_LEVEL, TO_CART, DELETE_CUTS, FIX_BROKEN_FORMATS, LOG_PATH)"
      "values"
      "('${stationName}', '${feedGroup}', '${dropboxPath}/*.${fileExt}', -100, -5000, ${cartNumber}, '${(U)deleteCuts:-n}', 'Y', '${dropboxPath}/rdimport.log')"
    )

    if doSQL "${(j: :)query}" ; then

      # Make sure we created the new dropbox
      dropboxID=$(doSQL "select ID from DROPBOXES where PATH = '${dropboxPath}/*.${fileExt}'")

      if [[ -z "${dropboxID}" ]] ; then

	warning "Unable to discern the new dropbox ID. Did the dropbox get created?"
	returnValue=1

      else
	echo ${dropboxID}
      fi

    else

      warning "Attempt to create new dropbox failed (${?}). Please seek professional advice."
      returnValue=1

    fi

  else

    returnValue=2

  fi

  return ${returnValue}
}

warning() {
  local message=${1}

  ${CAT} >&2 <<EOF

${BOLD}${RED}WARNING:${NORM}
$(${FMT} -w 79 <<< ${message})

EOF
}

error() {
  local message=${1}

  ${CAT} >&2 <<EOF

${RED}${BOLD}ERROR:${NORM}
$(${FMT} -w 79 <<< ${message})

EOF
  echo 254
  return 254
}

##########################################################################################
## Script main line
##########################################################################################

# The shell commands we will use in this script.
typeset -a ourCommands
ourCommands=(
  awk
  cat
  chmod
  column
  cp
  crontab
  diff
  fmt
  getopt
  grep
  kill
  less
  mkdir
  mktemp
  mv
  pidof
  podget
  rm
  sed
  sort
  wc
  wget
  xsltproc
)

# Find the executables we need; this uses a little old fashioned shell and
# a ZSH trick -- the (U) in the eval(1) says to evaluate the parameter as
# all upper case letters. We will use the command names in upper case as
# variables by which to call the commands later in this function.
for C in ${ourCommands} ; do
  for D in ${path} ; do
    [[ -x ${D}/${C} ]] && { eval ${(U)C}=${D}/${C} ; break }
  done
  [[ -x $(eval echo \$${(U)C}) ]] || { echo "Cannot find ${C}! Done."; return 1 }
done

# Set some defaults, and see below for more ways to set these.
DIR_CONFIG=%PODGET_DIR_CONFIG%
CONFIG_CORE=podgetrc
CONFIG_NOTIFY=notifyrc
VERBOSE=0

TEMP=$(${GETOPT} -o c:Dd:Vvg:h --long config:,dir-config:,version,verbose,group:,help -n "${0##*/}" -- "${@}")
if (( ${?} != 0 )) ; then echo "Terminating..." >&2 ; return 1 ; fi
# Note the quotes around ${TEMP}: they are essential!
eval set -- "${TEMP}"
while : ; do
  case "${1}" in
    -c|--conf*) CONFIG_CORE=${2} ; shift 2 ;;
    -d|--dir-*) DIR_CONFIG=${2} ; shift 2 ;;
    -g|--grou*) group=${2} ; shift 2 ;;
    -h|--help*) usage ${0##*/} ; exit ;;
    -v|--verb*) VERBOSE=1 ; PASSFILE=none ; shift ;;
    -V|--vers*) showVersion=1 ; shift ;;
    --) shift ; break ;;
    *) echo "Internal error!" >&2 ; return 1 ;;
  esac
done

if ((showVersion)) ; then
  echo "${0##*/}: version ${vMajor}.${vMinor}.${vPatch}-${${vHash#\$Hash: }%$}"
  exit 0
fi

RED="${fg_bold[red]}"
BOLD="${bold_color}"
NORM="${reset_color}"
# This script is compatible with Rivendell database verson:
rdDBVersionCompatible=242
# Hard code this for now.
fileExt=mp3

# Ensure the configuration directory exists.
if [[ ! -d ${DIR_CONFIG} ]] ; then
  if ! ${MKDIR} -p ${DIR_CONFIG} ; then

    exit $(error "Unable to create configuration directory '${DIR_CONFIG}'. Make sure your permissions are set so that you have file create and write
rights to the ${DIR_CONFIG} directory. Cannot continue.")

  fi
fi

# Run podget(1) if it appears it has never been run.
failCount=1
maxAttempts=10
until [[ -r ${DIR_CONFIG}/${CONFIG_CORE} ]] ; do

  warning "Unable to read configuration file ${DIR_CONFIG}/${CONFIG_CORE}. Running podget to create a new configuration..."

  ${PODGET} --dir_config ${DIR_CONFIG}

  ((failCount++ > maxAttempts )) &&
    exit $(error "Unable to create ${DIR_CONFIG}/${CONFIG_CORE} ${maxAttempts} times. I quit.")

done

[[ -r ${DIR_CONFIG}/${CONFIG_CORE} ]] && source ${DIR_CONFIG}/${CONFIG_CORE}
[[ -n "${CONFIG_SERVERLIST}" ]] ||
  exit $(error "Failed to get a setting for 'CONFIG_SERVERLIST'. Does '${DIR_CONFIG}/${CONFIG_CORE}' exist?")

##########################################################################################
## The guts of why we are here.
##########################################################################################

typeset -a menu command
typeset -R 2 count

while : ; do
    count=0

    menu=(
      "Quit"
      "Add or Replace a podcast feed"
      "Delete or disable a podcast feed"
      "Enable a disabled podcast feed"
      "Show the complete list of podcast feeds"
      "Show most recent podget run status"
      "Show most recent podget diagnostic status"
      "View and set the podget run schedule \(crontab\)"
      "Show Rivendell dropboxes"
      "Show Rivendell dropbox status"
      "\[Advanced\] Edit the podcast list with '${EDITOR:-${VISUAL:-nano}}'"
      "\[Advanced\] Edit the notification configuration with '${EDITOR:-${VISUAL:-nano}}'"
      "\[Advanced\] Edit ${USER}\'s crontab file"
    )
    command=(
      'addOrReplaceFeed ${0##*/} ${VERBOSE}'
      'deleteFeed ${0##*/} ${VERBOSE}'
      'enableFeed ${0##*/} ${VERBOSE}'
      'listFeeds ${0##*/} ${VERBOSE}'
      'showLastStatus ${0##*/} out ${VERBOSE}'
      'showLastStatus ${0##*/} err ${VERBOSE}'
      'editSchedule ${0##*/} ${VERBOSE}'
      'showRDDropboxes ${0##*/} ${VERBOSE}'
      'showDropboxStatus ${0##*/} ${VERBOSE}'
      'editFile ${0##*/} ${DIR_CONFIG}/${CONFIG_SERVERLIST} ${VERBOSE}'
      'editFile ${0##*/} ${DIR_CONFIG}/${CONFIG_NOTIFY} ${VERBOSE}'
      'cronEdit ${0##*/} ${VERBOSE}'
    )
    windowTitle=(
      "Add Feed"
      "Delete Feed"
      "Enable Feed"
      "List Feeds"
      "podget Run Status"
      "podget Diagnostic Status"
      "Edit run Schedule"
      "Rivendell Dropboxes"
      "Rivendell Dropbox Status"
      "Edit serverlist"
      "Edit notifyrc"
      "Edit crontab"
    )

    # Set the window title.
    printf '\033]0;%s\007' Kuchota

    for menuItem in ${menu} ; do
	echo "${count}) $(eval echo ${menuItem})"
	(( count++ ))
    done
    echo

    read choice\?"Type your choice and press <Enter>: "

    echo

    if [[ -z "${choice}" ]] ; then
      echo "Please enter a number between 0 and $(( count - 1 ))."
      read ok\?"Press <Enter> to continue. "

    elif [[ ${choice} =~ '^[0Qq]$' ]] ; then
      printf '\033]0;%s\007' ''
      exit

    elif [[ "${choice}" =~ '[[:space:]]*[[:alpha:]]+' ]] ; then
      echo "'${choice}' is not an option. Please enter a number between 0 and $(( count - 1 ))."
      read ok\?"Press <Enter> to continue. "

    elif [[ "${choice}" =~ '[[:space:]]*[[:alnum:]]+[[:space:]]+' ]] ; then
      echo "'${choice}' is not an option (watch your spaces). Please enter a number between 0 and $(( count - 1 ))."
      read ok\?"Press <Enter> to continue. "

    elif (( choice > 0 && choice < count )) ; then

      # Set the window title for this menu choice then run the command.
      printf '\033]0;%s\007' ${windoTitle[${choice}]}
      eval $(echo ${command[${choice}]})

    else
	echo "'${choice}' is not an option. Please enter a number between 0 and $(( count - 1 ))."
	read ok\?"Press <Enter> to continue. "

    fi

    # As found in ZSH module zsh/terminfo.
    echoti clear
done

exit

# Local Variables: ***
# mode:shell-script ***
# indent-tabs-mode: f ***
# sh-indentation: 2 ***
# sh-basic-offset: 2 ***
# sh-indent-for-do: 0 ***
# sh-indent-after-do: + ***
# sh-indent-comment: t ***
# sh-indent-after-case: + ***
# sh-indent-after-done: 0 ***
# sh-indent-after-else: + ***
# sh-indent-after-if: + ***
# sh-indent-after-loop-construct: + ***
# sh-indent-after-open: + ***
# sh-indent-after-switch: + ***
# sh-indent-for-case-alt: ++ ***
# sh-indent-for-case-label: + ***
# sh-indent-for-continuation: + ***
# sh-indent-for-done: 0 ***
# sh-indent-for-else: 0 ***
# sh-indent-for-fi: 0 ***
# sh-indent-for-then: 0 ***
# End: ***
