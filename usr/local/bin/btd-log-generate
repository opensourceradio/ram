#!/bin/zsh
# shellcheck shell=bash disable=SC1105,SC2016,SC2154,SC2190,SC2205,SC2211,SC2284
# SC2016: "$Hash" is not a variable.
# SC2154: all referenced variables are assigned indirectly.
# SC2190: ZSH associative arrays are different from BASH.
# SC2205: this is an arithmetic expression, not a subshell
# SC2211: this is not a glob, we are checking the return value of the previous command (${?})
# SC2284: this is an arithmetic expression, not a subshell

##############################################################################
##############################################################################
##
## Generate Logs for all Rivendell services.
##
## See also: rdlogmanager --help
##
##############################################################################
##############################################################################

zmodload zsh/datetime

# This script complies with Semantic Versioning: http://semver.org/
declare -ri v_major=0
declare -ri v_minor=2
declare -ri v_patch=8
declare -r v_hash='$Hash$'

declare -ir one_day=$(( 60 * 60 * 24))

declare -i DEBUG=0
declare -i SHOW_VERSION=0

# Do not overwrite existing log by default (see options below).
# Sigh, rdlogmanager(1) has an "unusual" sense of "force" vs "preserve".
declare PRESERVE="-P"

# Default number of days for which to generate Logs.
declare -i DAYS=1

# Location of "hook" scripts -- run after log generation.
btd_log_generate_hook_dir="/usr/local/etc/btd/log-generate-hooks.d"

function usage() {
  local my_name="${1:t}"

  cat <<EOF
${my_name} [ --days (-d) <number-of-days> ] [ --start (-s) <date> ] [ --end (-e) <date> ]
                 [ --force (-f) ] [ --service <name> ]
                 [ --hook-dir <directory-path> ]
                 [ --help (-h) ] [ --version (-v) ]

$(${FMT} <<<"${my_name} uses rdlogmanager(1) to generate Logs for all SERVICES. With no optional arguments, ${my_name} generates Logs for 'tomorrow' (the day after the current day). Also with no optional arguments, on Fridays ${my_name} generates Logs for all SERVICES for Saturday, Sunday and Monday.")

$(${FMT} <<<"Without the optional '--service' parameter, ${my_name} generates logs for all Rivendell Services. Specify a single service with the '--service <NAME>' option.")

$(${FMT} <<<"By default, ${my_name} does not overwrite existing Logs (i.e., rdlogmanager(1) is invoked with the '-P' [preserve] option). You may force overwriting existing Logs by calling ${my_name} with the '--force' ('-f') option.")

$(${FMT} <<<"You may specify a range of days for which rdlogmanager(1) should generate Logs by calling ${my_name} with the '--start' and '--end' options and specifying the date in YYYY-MM-DD format. Specifying '--end' without '--start' assumes 'tomorrow' as the starting day. Specifying '--start' without '--end' means 'generate a Log just for that day'. Specifying neither '--start' nor '--end' causes ${my_name} to generate Logs for 'tomorrow' (see above).")

$(${FMT} <<<"Alternatively, you may instruct ${my_name} to generate a specific number of days of Logs with the --days <D> option. The starting day in this case is 'tomorrow'.")

$(${FMT} <<<"${my_name} saves the output of rdlogmanager(1) in the Desktop folder of the invoking user, and also emails the output to the addresses listed in the MAILTO shell variable.")

$(${FMT} <<<"${my_name} can process logs after they are generated. Simply place a ZSH-compatible script in ${btd_log_generate_hook_dir}. Filenames starting with '.' and '_' are ignored. Scripts should exit with non-zero status if something goes wrong. Specify an alternate hook directory with the --hook-dir option. Scripts in ${btd_log_generate_hook_dir} are executed in lexicographic order by hook filename.")

$(${FMT} <<<"Enable ZSH debugging with the --debug (-D) option.")

$(${FMT} <<<"See rdlogmanager(1) and 'rdlogmanager --help' for additional details.")

EOF
}

# run_post_gen_hooks runs scripts on the named log.
function run_post_gen_hooks() {
  local -r log_name="${1}"
  local -i return_value=0
  if [[ -d "${btd_log_generate_hook_dir}" ]] ; then
    # Run all post log-generation hooks.
    for hook in "${btd_log_generate_hook_dir}"/* ; do
      # Skip files starting with "." and "_".
      [[ "${hook:t}" =~ ^[._] ]] && continue
      if ! ${ZSH} "${hook}" "${log_name}" ; then
	return_value="${?}"
      fi
    done
  fi
  return "${return_value}"
}

############# BEGIN external shell commands used in this script. #############
# This script uses these 9 external commands.
# Look for them in their upper case, parameter expanded form.
typeset -a our_commands
our_commands=( chmod cp fmt getopt logger mktemp rdlogmanager rm zsh )
# Find the executables we need; this uses some basic shell and a ZSH trick:
# the (U) in the eval says to evaluate the parameter as all upper case
# letters. This snippet generates shell parameters representing the upper case
# equivalent of the command names and sets the parameter values to the full path
# of the commands.
# Refresh this segment in Emacs by marking the appropriate region (or the whole
# buffer with C-xH) and replacing it with C-uM-|mk-ourCommands --script (shell-command-on-region).
typeset C D
for C in ${our_commands[*]} ; do
  # shellcheck disable=SC2154 # ZSH: ${path} is set by the shell.
  for D in ${path} ; do
    # shellcheck disable=SC2140,SC2086 # we need the quotes
    [[ -x "${D}/${C}" ]] && { eval "${(U)C//-/_}"="${D}/${C}" ; break ; }
  done
  [[ -x $(eval print \$"${(U)C//-/_}") ]] || { print "Cannot find ${C}! Done."; return 1 ; }
done
unset our_commands C D
############## END external shell commands used in this script. ##############

if ! TEMP=$(${GETOPT} -o Dd:e:fhs:v --long debug,days:,force,help,hook-dir:,version,service:,start:,end: -n "${0:t}" -- "${@}") ; then
  print "getopt(1) Fatal Error (${?}). Terminating." >&2
  return 1
fi
eval set -- "${TEMP}"
while :
do
  case "${1}" in
    -d|--days) DAYS=${2} ; shift 2 ;;
    -f|--force) unset PRESERVE ; shift ;;
    --hook-dir) btd_log_generate_hook_dir="${2}" ; shift 2 ;;
    --service) SERVICE=${2} ; shift 2 ;;
    -s|--start) START_DATE=${2} ; shift 2 ;;
    -e|--end) END_DATE=${2} ; shift 2 ;;
    -D|--debug) DEBUG=1 ; shift ;;
    -h|--help) usage "${0}" ; exit ;;
    -v|--vers*) SHOW_VERSION=1 ; shift ;;
    --) shift ; break ;;
    *) echo 'Internal error!' ; exit 1 ;;
  esac
done
unset TEMP

if ((SHOW_VERSION)) ; then
  typeset commit_hash="${v_hash}"
  [[ "${v_hash}" == '$Hash$' ]] &&
    commit_hash="prerelase"
  print "${0:t}: version ${v_major}.${v_minor}.${v_patch}-${${commit_hash#\$Hash: }%$}"
  exit 0
fi

exec 1> "/var/tmp/${0:t}.out"
exec 2> "/var/tmp/${0:t}.err"

if [[ -r /usr/bin/zsh-functions ]] ; then
  source /usr/bin/zsh-functions
elif [[ -r /usr/local/bin/zsh-functions ]] ; then
  source /usr/local/bin/zsh-functions
else
  ${LOGGER} --stderr -t "${0:t}" -p local7.err -i "ERROR: Cannot continue without zsh-functions! (Error: ${?})"
  exit 3
fi

((DEBUG)) && setopt xtrace

# Exit values from rdlogmanager(1). Taken from Rivendell 3.6.2.
declare -A rdlogmanager_exit_values
rdlogmanager_exit_values=(
  0  "Normal exit"
  2  "Unable to open database"
  4  "Unknown/invalid command line option"
  5  "Unable to overwrite output [-P given]"
  6  "No such service"
  7  "No such log"
  8  "No such report"
  9  "Log generation failed"
  10 "Schedule import failed"
  11 "Insufficient permissions"
  12 "Report generation failed"
)

declare -ri right_now=${EPOCHSECONDS}
declare -r MAILTO=${MAILTO:-"dklann@broadcasttool.com"}

# Gather all the Services from Rivendell unless they asked for a
# specific Service. services is an associative array indexed by the
# service name. The value is the log name "template".
declare oIFS="${IFS}"
IFS=$'\t\n'
typeset -A services
if [[ -n "${SERVICE}" ]] ; then
  declare -r service_selection_clause=" where name = '${SERVICE}'"
fi
# SC2207: ZSH does not have BASH mapfile.
# shellcheck disable=SC2207
services=( $(doSQL "select NAME,NAME_TEMPLATE from SERVICES${service_selection_clause}") )
IFS="${oIFS}"
unset oIFS

declare output_file
if ! output_file=$(${MKTEMP}) ; then
  ${LOGGER} --stderr -t "${0:t}" -p local7.err -i "Error trying to create temporary file. Cannot continue."
  exit 3
fi
# No changes to the value of the parameter.
declare -r output_file

# SC2064: I want this trap argument to expand now.
# shellcheck disable=SC2064
trap "${RM} -f '${output_file}' ; exit ;" 0 1 2 3

# Get the current full weekday name (%A) (but permit setting it in
# the calling environment for testing).
declare -r today=${TODAY:-$(strftime "%A" "${right_now}")}

# With no command line options, Logs are generated for tomorrow.
# SC2155: I *know* the strftime() works.
# shellcheck disable=SC2155
declare -r tomorrow_YYYYMMDD=$(strftime "%F" $(( right_now + one_day )))
# SC2155: See above.
# shellcheck disable=SC2155
declare -ri tomorrow_seconds=$(strftime -r "%F" "${tomorrow_YYYYMMDD}")

declare -i start_date_seconds
declare -i end_date_seconds

# Set the start date to tomorrow if not specified on the command line.
if [[ -n "${START_DATE}" ]] ; then
  if ! [[ "${START_DATE}" =~ [[:digit:]]{4}(-[[:digit:]]{2}){2} ]] ; then
    ${LOGGER} --stderr -t "${0:t}" -p local7.err -i "ERROR: Cannot make sense of Start Date '${START_DATE}'. I quit."
    exit
  fi
  start_date_seconds=$(strftime -r "%F" "${START_DATE}")
else
  start_date_seconds="${tomorrow_seconds}"
fi

# Set the end date to the same as the start date if not specified on
# the command line.
if [[ -n "${END_DATE}" ]] ; then
  if ! [[ "${END_DATE}" =~ [[:digit:]]{4}(-[[:digit:]]{2}){2} ]] ; then
    ${LOGGER} --stderr -t "${0:t}" -p local7.err -i "ERROR: Cannot make sense of End Date '${END_DATE}'. I quit."
    exit
  fi
  end_date_seconds=$(strftime -r "%F" "${END_DATE}")
else
  end_date_seconds="${start_date_seconds}"
fi

# Same thing if number of days was specified on the command line.
if ((DAYS > 1)) ; then
  end_date_seconds=$((start_date_seconds + (one_day * DAYS)))
fi

# For each day offset and for each service found:
# Generate a Log (-g) for tomorrow or the specific (set of) day(s).
#   preserve existing Logs (-P) unless we are called with --force
#   service: (e.g.: "Production") (-s)
#   merge traffic (-t)
#   merge music (-m)
#   day spec (-d) is "tomorrow" (0) unless ${START_DATE} is specified
declare -ri start_day_offset=$(( ( start_date_seconds - tomorrow_seconds - one_day ) / one_day ))
declare -ri end_day_offset=$(( ( end_date_seconds - tomorrow_seconds - one_day ) / one_day ))

for (( day_offset = start_day_offset + 1; day_offset <= (end_day_offset + 1); day_offset++ )) ; do
  for service in ${(k)services[*]} ; do
    if ! ${RDLOGMANAGER} -s "${service}" -g -t -m -d "${day_offset}" "${PRESERVE}" 2>&1 ; then
      ${LOGGER} --stderr -t "${0:t}" -p local7.info -i "INFO: ${RDLOGMANAGER} (${day_offset}) exited with value ${?} ('${rdlogmanager_exit_values[${?}]}')"
    fi
    if ((? == 0)) ; then
      if ! run_post_gen_hooks "$(strftime """${services[${service}]}""" """${start_date_seconds}")" ; then
	${LOGGER} --stderr -t "${0:t}" -p local7.notice -i "NOTICE: run_post_gen_hooks returned with non-zero value: ${?}"
      fi
    fi

    # Also create Logs for Sunday and Monday if ${today} is
    # 'Friday' and we do not have an End Date.
    if [[ "${today}" == Friday ]] && [[ -z "${END_DATE}" ]] ; then
      if ! ${RDLOGMANAGER} -s "${service}" -g -t -m -d 1 "${PRESERVE}" 2>&1 ; then
	${LOGGER} --stderr -t "${0:t}" -p local7.info -i "INFO: ${RDLOGMANAGER} (Sunday) exited with value ${?} ('${rdlogmanager_exit_values[${?}]}')"
      fi
      if ((? == 0)) ; then
	if ! run_post_gen_hooks "$(strftime """${services[${service}]}""" """$((start_date_seconds + one_day))")" ; then
	  ${LOGGER} --stderr -t "${0:t}" -p local7.notice -i "NOTICE: run_post_gen_hooks returned with non-zero value: ${?}"
	fi
      fi
      if ! ${RDLOGMANAGER} -s "${service}" -g -t -m -d 2 "${PRESERVE}" 2>&1 ; then
	${LOGGER} --stderr -t "${0:t}" -p local7.info -i "INFO: ${RDLOGMANAGER} (Monday) exited with value ${?} ('${rdlogmanager_exit_values[${?}]}')"
      fi
      if ((? == 0)) ; then
	if ! run_post_gen_hooks "$(strftime """${services[${service}]}""" """$((start_date_seconds + (one_day*2)))")" ; then
	  ${LOGGER} --stderr -t "${0:t}" -p local7.notice -i "NOTICE: run_post_gen_hooks returned with non-zero value: ${?}"
	fi
      fi
    fi
  done
done > "${output_file}"

# Save a copy in the user "rd"'s Desktop folder if such a folder exists.
#
# BUG ALERT: This works only for Rivendell installations that follow the
# "reference" installation methodology.
#
# BUG ALERT: The directory for ${final_output_file} must already exist and be
# writeable by the user ID running this script. See parameter 'RnRmlOwner' in
# /etc/rd.conf if running from RDCatch.
typeset -r final_output_file="/home/rd/Desktop/RD-Log-Generate.txt"
if [[ -d "${final_output_file%/*}" ]] ; then
  if ${CP} "${output_file}" "${final_output_file}" ; then
    ${CHMOD} a+r "${final_output_file}"
    ${LOGGER} --stderr -t "${0:t}" -p local7.info -i "INFO: copied output file to ${final_output_file}."
  else
    ${LOGGER} --stderr -t "${0:t}" -p local7.notice -i "NOTICE: unable to copy output file to '${final_output_file}' (${?})."
  fi
else
  ${LOGGER} --stderr -t "${0:t}" -p local7.notice -i "NOTICE: '${final_output_file%/*}' does not exist. See '${output_file}'."
fi

# Send email to the addresses in $MAILTO with the same output as is on
# the desktop.
if [[ -s "${output_file}" ]] ; then
  sendNotification "${0:t}" "${MAILTO}" LOG-GENERATE "Rivendell Logs have been generated." "${output_file}"
else
  sendNotification "${0:t}" "${MAILTO}" LOG-GENERATE "rdlogmanager(1) created no output. Did it run? Better check on it."
fi

exit

# Local Variables: ***
# mode:shell-script ***
# indent-tabs-mode: f ***
# sh-indentation: 2 ***
# sh-basic-offset: 2 ***
# sh-indent-for-do: 0 ***
# sh-indent-after-do: + ***
# sh-indent-comment: t ***
# sh-indent-after-case: + ***
# sh-indent-after-done: 0 ***
# sh-indent-after-else: + ***
# sh-indent-after-if: + ***
# sh-indent-after-loop-construct: + ***
# sh-indent-after-open: + ***
# sh-indent-after-switch: + ***
# sh-indent-for-case-alt: ++ ***
# sh-indent-for-case-label: + ***
# sh-indent-for-continuation: + ***
# sh-indent-for-done: 0 ***
# sh-indent-for-else: 0 ***
# sh-indent-for-fi: 0 ***
# sh-indent-for-then: 0 ***
# End: ***
