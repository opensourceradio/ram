#!/bin/zsh
# shellcheck shell=bash disable=SC2016,SC2034,SC2154,SC2190,SC2207
# SC2016: $Hash is not a variable, it's a token that gets replaced by git(1)
# SC2034: shellcheck does not know about ZSH param expansions.
# SC2154: the only "unassigned" parameters *should be* upper case command names.
# SC2190: ZSH associative arrays work differently from Bash associative arrays.
# SC2207: mapfile or read -a are Bash-isms.

zmodload zsh/stat
zmodload zsh/datetime

# This script complies with Semantic Versioning: http://semver.org/
declare -ri v_major=0
declare -ri v_minor=1
declare -ri v_patch=8
declare -r v_hash='$Hash$'

# Prefer the instance in /usr/bin (that gets installed with the
# rdfetch package) over /usr/local/bin
if [[ -f /usr/bin/zsh-functions ]] ; then
    source /usr/bin/zsh-functions
elif [[ -f /usr/local/bin/zsh-functions ]] ; then
    source /usr/local/bin/zsh-functions
else
    print "Missing zsh-functions library. Cannot continue." >&2
    exit 1
fi

typeset -i INTERACTIVE=0
typeset -i CHECK_STRANDED_FILES=0
typeset -i VERBOSE=0
typeset -i SHOW_VERSION=0

typeset -ri CURRENT_TIME=${EPOCHSECONDS}
typeset -ri ONE_DAY=$((60 * 60 * 24))

# Attempt to kill all PIDs passed. Try first without privilege
# escalation, then try _with_ privilege escalation.
# Returns with non-zero status if we are unable to kill any of the
# passed PIDs.
function kill_with_privilege() {
    local -i pid
    local -ir attempt_limit=5
    local -i count=0
    local -i return_value=0
    for pid ; do
	while ((count < attempt_limit)) ; do
	    ((VERBOSE)) && printf "Attempting to terminate process ID %d\n" "${pid}" >&2
	    ${KILL} "${pid}"
	    ${SLEEP} 0.5
	    if ! [[ -d "/proc/${pid}" ]] ; then
		continue 2	# next pid in the for loop
	    fi
	    ${SUDO} "${KILL}" "${pid}"
	    ${SLEEP} 0.5
	    if ! [[ -d "/proc/${pid}" ]] ; then
		continue 2	# next pid in the for loop
	    fi
	    ${SLEEP} 0.5
	    ((count++))
	done
	printf 'Unable to terminate process %s. Please seek help!\n' "${pid}" >&2
	return_value=1
    done
    return "${return_value}"
}

# get_yes_no() repeatedly prompts with ${our_prompt} to /dev/tty until
# the user responds affirmatively or negatively (reading from
# /dev/tty). Returns 0 ("success") for a "yes"-like response and 1
# ("non-success") for a "no"-like response to the given prompt.
function get_yes_no() {
    local -r our_prompt="${1}"
    local -i again=0

    local response=''
    until [[ "${(L)response}" =~ ^(no*|y(es)*)$ ]] ; do
	((again)) && print "Please respond with 'yes' ('y') or 'no' ('n')." > /dev/tty
	print "${our_prompt} [y or n] \c" > /dev/tty
	# SC2034: response is used, but in a non-Bash way, see below.
	# shellcheck disable=SC2034
	read -r response < /dev/tty
	again=1
    done
    [[ "${(L)response}" =~ n ]] && return 1
    return 0
}

# Show how to use this command.
function usage() {
  local -r my_name="${1:t}"

  ${CAT} <<EOF
NAME

${my_name}

SYNOPSIS

${my_name} [ --stranded-files (-s) ] [ --interactive (-i) ]
                  [ --help (-h) ] [ --version (-v) ]

DESCRIPTION

$(${FMT} <<<"${my_name} performs several checks on Rivendell dropboxes in order to ensure their consistent and reliable functionality. Checks include:

  * running processes for all defined dropboxes

  * 'left-over' processes from deleted or changed dropboxes

  * existence of dropbox folders (directories)

  * existence of Carts for dropboxes that specify them

  * 'hung' import processes (rdxport.cgi)

  * 'stranded' (unimported) files in dropbox directories") (optional)

$(${FMT} <<<"${my_name} takes specific action in cases where it makes sense and is safe:

  * starts any missing dropbox processes

  * terminates any 'hung' import processes")

$(${FMT} <<<"Specify '--interactive' (short option: '-i') to have ${my_name} prompt before taking any action.")

$(${FMT} <<<"Specify '--stranded-files' (short option: '-s') to have ${my_name} look for and report on files in dropbox directories that have not been imported.")

EOF
}

############# BEGIN external shell commands used in this script. #############
# This script uses these 14 external commands.
# Look for them in their upper case, parameter expanded form.
typeset -a our_commands
our_commands=( cat date find fmt getopt grep kill pidof ps sed sendusr1 sleep sort sudo )
# Find the executables we need; this uses some basic shell and a ZSH trick:
# the (U) in the eval says to evaluate the parameter as all upper case
# letters. This snippet generates shell parameters representing the upper case
# equivalent of the command names and sets the parameter values to the full path
# of the commands.
# Refresh this segment in Emacs by marking the appropriate region (or the whole
# buffer with C-xH) and replacing it with C-uM-|mk-ourCommands (shell-command-on-region).
typeset C D
for C in ${our_commands[*]} ; do
  # shellcheck disable=SC2154 # ZSH: ${path} is set by the shell.
  for D in ${path} ; do
    # shellcheck disable=SC2140,SC2086 # we need the quotes
    [[ -x "${D}/${C}" ]] && { eval "${(U)C//-/_}"="${D}/${C}" ; break ; }
  done
  [[ -x $(eval print \$"${(U)C//-/_}") ]] || { print "Cannot find ${C}! Done."; return 1 ; }
done
unset our_commands C D
############## END external shell commands used in this script. ##############

if ! TEMP=$(${GETOPT} -o hisVv --long help,interactive,stranded-files,version,verbose -n "${0:t}" -- "${@}") ; then
  print "getopt(1) Fatal Error (${?}). Terminating..." >&2
  return 1
fi
eval set -- "${TEMP}"
while : ; do
    # VERBOSE is used, but in a non-Bash way.
    # shellcheck disable=SC2034
    case "${1}" in
	-h|--help) usage "${0}" ; exit ;;
	-i|--inter*) INTERACTIVE=1 ; shift ;;
	-s|--stranded*) CHECK_STRANDED_FILES=1 ; shift ;;
	-V|--version) SHOW_VERSION=1 ; shift ;;
	-v|--verbose) ((VERBOSE += 1)) ; shift ;;
	--) shift ; break ;;
	*) print "${0:t}: getopt internal error!. Terminating..." >&2 ; return 1 ;;
    esac
done
unset TEMP

if ((SHOW_VERSION)) ; then
    typeset commit_hash="${v_hash}"
    [[ "${v_hash}" == '$Hash$' ]] &&
	commit_hash="prerelase"
    print "${0:t}: version ${v_major}.${v_minor}.${v_patch}-${${commit_hash#\$Hash: }%$}"
    exit 0
fi
((VERBOSE)) && printf "%s: beginning audit of Rivendell dropboxes.\n" "${0:t}" >&2

typeset oIFS="${IFS}"
# hostname -s *must* match the station name in the STATIONS table.
typeset -r station=$(hostname -s)
typeset -r myFS='^:^'

# Get the count of dropboxes and running processes.
typeset -ri box_count=$(doSQL "select count(*) from DROPBOXES where station_name='${station}'")
typeset -ri pid_count=$(${PIDOF} rdimport | wc -w)
((VERBOSE)) && printf "Dropbox count: %d, PID count: %d\n" "${box_count}" "${pid_count}" >&2

if ((box_count > pid_count)) ; then
    printf "Found %d dropboxes, but only %d processes.\n" "${box_count}" "${pid_count}" >&2
elif ((pid_count > box_count)) ; then
    printf "Found %d dropboxes, but there are too many (%d) processes.\n" "${box_count}" "${pid_count}" >&2
else
    ((VERBOSE)) && printf "Good! %d dropboxes and %d dropbox processes.\n" "${box_count}" "${pid_count}" >&2
fi

# procs is an associative array containing the full command line,
# indexed by the PID.
typeset -A procs
IFS=$'\n\t'
# NOTE: the whitespace between %p (PID) and %a (ARGS) should be a single <TAB>.
procs=($(PS_PERSONALITY=aix ${PS} -eo "%p$(print '\t\c')%a" | ${GREP} -v "${GREP}" | ${GREP} "rdimport" | ${SED} -e 's/^  *//'))
((VERBOSE > 1)) && printf "rdimport processes:\n%s" "${(v)procs[*]}" >&2

# path_specs is an associative array containing the dropbox cart number
# (may be 0) and the path spec, indexed by the dropbox ID.
typeset -A path_specs
path_specs=($(doSQL "select ID,concat(TO_CART,'${myFS}',PATH) from DROPBOXES where STATION_NAME='${station}' order by TO_CART"))
((VERBOSE > 1)) && printf "path_specs:\n%s" "${(v)path_specs[*]}" >&2

# Check if all defined dropbox processes are running.
((VERBOSE)) && print "Checking for running processes for all dropboxes..." >&2
typeset -i to_cart
for id in ${(k)path_specs[*]} ; do
    path_dir="${${path_specs[${id}]#*${myFS}}%/*}"
    to_cart="${path_specs[${id}]%${myFS}*}"

    if ! ${GREP} -F -q "${path_specs[${id}]#*${myFS}}" <<<"${(v)procs[*]}" ; then
	printf "\tMissing dropbox process for dropbox ID %d ('%s', Cart # %d).\n" "${id}" \
	       "${path_specs[${id}]#*${myFS}}" "${to_cart}" >&2

	typeset -ir dropbox_path_count=$(doSQL "select count(*) from DROPBOX_PATHS where DROPBOX_ID = ${id}")
	((VERBOSE > 1)) && printf "dropbox_path_count for dropbox %d: %d\n" "${id}" "${dropbox_path_count}" >&2
	if ((dropbox_path_count > 0)) ; then
	    if ((INTERACTIVE)) ; then
		if get_yes_no "Reset dropbox '${path_specs[${id}]#*${myFS}}'? " ; then
		    if ! doSQL "delete from DROPBOX_PATHS where DROPBOX_ID = ${id}" ; then
			printf "Unable to reset dropbox '%s'. Please seek additional help.\n" "${path_specs[${id}]#*${myFS}}" >&2
		    fi
		fi
	    else
		((VERBOSE)) && printf "Resetting dropbox ID '%d' ('%s')\n" "${id}" "${path_specs[${id}]#*${myFS}}" >&2
		if ! doSQL "delete from DROPBOX_PATHS where DROPBOX_ID = ${id}" ; then
		    printf "Unable to reset dropbox '%s'. Please seek additional help.\n" "${path_specs[${id}]#*${myFS}}" >&2
		fi
	    fi
	else
	    if ((INTERACTIVE)) ; then
		if get_yes_no "Restart dropboxes? " ; then
		    if pidof_rdservice="$(${PIDOF} 'rdservice')" ; then
			# The Rivendell v3 way to restart all dropboxes.
			${SENDUSR1} "${pidof_rdservice}"
		    else
			# The pre-Rivendell v3 way to restart all dropboxes.
			kill_with_privilege "$(${PIDOF} rdcatchd)"
			# SC2046: we want the words of pidof to be split.
			# shellcheck disable=SC2046
			kill_with_privilege $(${PIDOF} rdimport)
		    fi

		    print "Dropboxes have been restarted."
		fi
	    else
		# SC2016: I do not want anything to expand in this string
		# shellcheck disable=SC2016
		printf '\tMight want to restart dropboxes as appropriate.\n' >&2
	    fi
	fi
    fi
done

# Other way around: check if all running processes have a dropbox
# defined. extract the dropbox IDs from the rdimport processes and
# compare them to the list of dropbox IDs from the database. Also look
# for dropboxes that have no Path Spec defined.
typeset -i pid
((VERBOSE)) && print "Checking whether all running dropbox processes have a dropbox configured..." >&2
for pid in ${(k)procs[*]} ; do
    # BUG ALERT: This expansion assumes '--drop-box' follows
    # '--persistent-dropbox-id=' in the ps(1) output.
    typeset process_dropbox_id="${${procs[${pid}]#*persistent-dropbox-id=}% --drop-box*}"
    typeset process_path_spec="${procs[${pid}]/* \///}"
    if [[ "${process_path_spec#/usr/bin/rdimport }" =~ ^/ ]] ; then
	if ! ${GREP} -F -q "${process_path_spec}" <<<"${(v)path_specs[*]}" ; then
	    printf "\tMissing dropbox for proccess with PATH specifier: %s\n" "${process_path_spec}" >&2
	if ((INTERACTIVE)) ; then
	    if get_yes_no "Terminate process ID ${pid}? " ; then
		kill_with_privilege "${pid}"
		print "Done."
	    else
		printf "OK, but you probably want to terminate process ID %d\n." "${pid}"
	    fi
	else
	    ((VERBOSE)) && printf "Terminating process ID %s... " "${pid}" >&2
	    kill_with_privilege "${pid}"
	    ((VERBOSE)) && print "done." >&2
	fi
	fi
    else
	# Deal with dropboxes that are missing a Path Spec.
	printf "\tDropbox ID %d has no Path Spec. Where should it look for files to import?\n" \
	       "${process_dropbox_id}"
    fi
done

# Check for valid directory names. Spaces and special characters are
# discouraged (and may even break dropboxes).
((VERBOSE)) && print "Checking for 'forbidden' directory names..." >&2
for path_spec in ${(v)path_specs[*]#*${myFS}} ; do
    typeset path_spec_dir=${path_spec%/*}
    if p=$(print "${path_spec_dir}" | ${GREP} --color=always '[|&\{\}#\$\<\>\?]') ; then
	${CAT} <<EndOfText >&2

One ore more directory components in Dropbox PATH spec
${p}
contains one of the characters |, &, {, }, # \$, <, >, and ?.
Please consider choosing a PATH spec without these characters.

EndOfText
    fi
done

# Check for existence of dropbox directories.
((VERBOSE)) && print "Checking for dropbox directories..." >&2
for path_spec in ${(v)path_specs[*]#*${myFS}} ; do
    typeset path_spec_dir=${path_spec%/*}
    if ! [[ -d ${path_spec_dir} ]] ; then
	printf "Missing directory (%s) for dropbox PATH specifier: %s\n" \
	       "${path_spec_dir}" "${path_spec}" >&2
    fi
done

typeset -a spinners
# SC1003: Not escaping a single-quote, quoting an escaped backslash.
# shellcheck disable=SC1003
spinners=('|' '/' '-' '\\')
typeset -ir spinner_count="${#spinners}"
typeset -i x=1

# Check for Cart Numbers as needed (some dropboxes create new Carts
# for all new imports).
((VERBOSE)) && print "Checking dropbox Cart numbers (this may take some time)..." >&2
for id in ${(k)path_specs[*]} ; do
    ((INTERACTIVE)) && printf "%c\r" "${spinners[$((x++ % spinner_count))]}" > /dev/tty
    to_cart=${path_specs[${id}]%${myFS}*}
    if ((to_cart > 0)) ; then
	typeset -i cut_count=$(doSQL "select count(*) from CUTS where CART_NUMBER = ${to_cart}")
	if ((cut_count < 1)) ; then
	    typeset cart_title=$(doSQL "select TITLE from CART where NUMBER = ${to_cart}")
	    if [[ -z "${cart_title}" ]] || [[ "${cart_title}" = '' ]] ; then
		printf "\r \nMissing TITLE in Cart %d associated with dropbox ID %d, PATH '%s'\n" \
		       "${to_cart}" "${id}" "${path_specs[${id}]#*${myFS}}" >&2
	    fi
	    printf "\r \nNo CUTS for CART %d (TITLE: '%s', dropbox ID %d, PATH '%s')\n" \
		   "${to_cart}" "${cart_title}" "${id}" "${path_specs[${id}]#*${myFS}}" >&2
	fi
    fi
done
((INTERACTIVE)) && printf "\r  \r\n" > /dev/tty

# Check for "hung" rdxport.cgi processes. Kill them if they are old or
# appear to be "stranded".
((VERBOSE)) && print "Checking for 'hung' rdxport.cgi processes..." >&2
declare -a possibly_hung_xport_procs
possibly_hung_xport_procs=( $(${PIDOF} 'rdxport.cgi') )
printf "Found %d possibly 'hung' Import processes...\n" "${#possibly_hung_xport_procs}"
for pid in ${possibly_hung_xport_procs[*]} ; do
    # SC2086: shellcheck sometimes gets confused about quotes
    # shellcheck disable=SC2086
    typeset process_start_time=$(${DATE} --date="$(${PS} -p ${pid} --format 'lstart=')" +%s)
    if ((process_start_time < (CURRENT_TIME - ONE_DAY))) ; then
	# SC2086: shellcheck is easily confused by quoting
	# shellcheck disable=SC2086
	printf "NOTICE: import process ID %d was started %s.\n" "${pid}" \
	       "$(strftime '%a, %d %b %Y %T %z' ${process_start_time})"
	if ((INTERACTIVE)) ; then
	    if get_yes_no "Terminate process ID ${pid}? " ; then
		kill_with_privilege "${pid}"
	    fi
	    print "Killed."
	else
	    ((VERBOSE)) && printf "Killing process ID %s: " "${pid}" >&2
	    kill_with_privilege "${pid}"
	    ((VERBOSE)) && print "done." >&2
	fi
    fi
done

# Check for missing log settings in the dropboxes.
printf "Checking for missing Log settings in dropboxes...\n"
x=1
for id in ${(k)path_specs[*]} ; do
    ((INTERACTIVE)) && printf "%c\r" "${spinners[$((x++ % spinner_count))]}" > /dev/tty
    if okDatabaseStructure DROPBOXES:LOG_TO_SYSLOG ; then
	log_specs=$(doSQL "select concat(LOG_TO_SYSLOG,'${myFS}',LOG_PATH) from DROPBOXES where ID=${id}")
	if [[ "${log_specs%${myFS}*}" =~ [Nn] ]] ; then
	    if [[ -z "${log_specs#*${myFS}}" ]] ; then
		printf "Warning: no logging configured for dropbox ID %d, path spec %s\n" \
		       "${id}" "${path_specs[${id}]}"
	    fi
	fi
    else
	log_path=$(doSQL "select LOG_PATH from DROPBOXES where ID=${id}")
	if [[ -z "${log_path}" ]] ; then
		printf "Warning: no logging configured for dropbox ID %d, path spec %s\n" \
		       "${id}" "${path_specs[${id}]}"
	fi
    fi
done
((INTERACTIVE)) && printf "\r  \r\n" > /dev/tty

# A "stranded" file is one that is in a dropbox directory and is not
# registered in DROPBOX_PATHS. This likely means the file was never
# successfully imported. It may also mean the file does not match the
# pattern in DROPBOX.PATH.
x=1
if ((CHECK_STRANDED_FILES)) ; then
    typeset -A file_history
    file_history=($(doSQL "select DROPBOX_ID,FILE_PATH from DROPBOX_PATHS join DROPBOXES on (DROPBOX_ID = DROPBOXES.ID) where STATION_NAME='${station}'"))
    ((VERBOSE > 1)) && print "File history:\n${(v)file_history[*]}" >&2
    typeset -A dropbox_groups
    dropbox_groups=($(doSQL "select ID,GROUP_NAME from DROPBOXES where STATION_NAME='${station}'"))

    ((VERBOSE)) && print "Checking for 'stranded' files (in a dropbox folder, but not imported). This may take some time..." >&2

    # SC2086: shellcheck is easily confused by quoting and this
    # parameter expansion is pretty disgusting.
    # shellcheck disable=SC2086
    for path_dir in $(print ${(vj:\n:)${path_specs[*]#*${myFS}}%/*} | ${SORT} -u) ; do
	typeset -a possibly_stranded
	possibly_stranded=(
	    $(${FIND} "${path_dir}" -maxdepth 1 -type f -print | while read -r line ; do
		  declare escaped_line=""
		  escaped_line="$(print ${line} | perl -ne 's,([\[\]{}\?\&]),\\$1,g; print;')"
		  [[ "${escaped_line}" =~ (\.log|/@eaDir/) ]] && continue
		  [[ "${(v)file_history[*]}" =~ .*${escaped_line}.* ]] ||
		      print "${line}"
		  ((INTERACTIVE)) && printf "%c\r" "${spinners[$((x++ % spinner_count))]}" > /dev/tty
	      done)
	)
	if [[ -n "${possibly_stranded[*]}" ]] ; then
	    if ((${#possibly_stranded[*]} == 1)) ; then
		typeset thing='file'
		typeset plural='s'
	    else
		typeset thing=$(printf '%d files' "${#possibly_stranded[*]}")
		typeset plural=''
	    fi
	    printf "The following %s in dropbox folder '%s' appear%c to be stranded:\n" \
		   "${thing}" "${path_dir}" "${plural}"
	    print "\t${(oj:\n\t:)possibly_stranded[*]}"
	fi
    done
    ((INTERACTIVE)) && printf "\r  \r\n" > /dev/tty
fi

exit
